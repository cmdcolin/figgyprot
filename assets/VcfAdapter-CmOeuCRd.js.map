{"version":3,"file":"VcfAdapter-CmOeuCRd.js","sources":["../../node_modules/@jbrowse/plugin-variants/esm/VcfAdapter/VcfAdapter.js"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree';\nimport VcfParser from '@gmod/vcf';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { fetchAndMaybeUnzip, getProgressDisplayStr } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport VcfFeature from '../VcfFeature';\nclass VcfAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.calculatedIntervalTreeMap = {};\n    }\n    async getHeader() {\n        const { header } = await this.setup();\n        return header;\n    }\n    async getMetadata() {\n        const { parser } = await this.setup();\n        return parser.getMetadata();\n    }\n    async setupP(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager);\n        const buffer = await fetchAndMaybeUnzip(loc, opts);\n        const headerLines = [];\n        const featureMap = {};\n        let blockStart = 0;\n        const decoder = new TextDecoder('utf8');\n        let i = 0;\n        while (blockStart < buffer.length) {\n            const n = buffer.indexOf(10, blockStart);\n            const b = n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n);\n            const line = decoder.decode(b).trim();\n            if (line) {\n                if (line.startsWith('#')) {\n                    headerLines.push(line);\n                }\n                else {\n                    const ret = line.indexOf('\\t');\n                    const refName = line.slice(0, ret);\n                    if (!featureMap[refName]) {\n                        featureMap[refName] = [];\n                    }\n                    featureMap[refName].push(line);\n                }\n            }\n            if (i++ % 10000 === 0) {\n                statusCallback(`Loading ${getProgressDisplayStr(blockStart, buffer.length)}`);\n            }\n            blockStart = n + 1;\n        }\n        const header = headerLines.join('\\n');\n        const parser = new VcfParser({ header });\n        const intervalTreeMap = Object.fromEntries(Object.entries(featureMap).map(([refName, lines]) => [\n            refName,\n            (sc) => {\n                if (!this.calculatedIntervalTreeMap[refName]) {\n                    sc === null || sc === void 0 ? void 0 : sc('Parsing VCF data');\n                    let idx = 0;\n                    const intervalTree = new IntervalTree();\n                    for (const line of lines) {\n                        const f = new VcfFeature({\n                            variant: parser.parseLine(line),\n                            parser,\n                            id: `${this.id}-${refName}-${idx++}`,\n                        });\n                        intervalTree.insert([f.get('start'), f.get('end')], f);\n                    }\n                    this.calculatedIntervalTreeMap[refName] = intervalTree;\n                }\n                return this.calculatedIntervalTreeMap[refName];\n            },\n        ]));\n        return {\n            header,\n            parser,\n            intervalTreeMap,\n        };\n    }\n    async setup() {\n        if (!this.vcfFeatures) {\n            this.vcfFeatures = this.setupP().catch((e) => {\n                this.vcfFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.vcfFeatures;\n    }\n    async getRefNames(_ = {}) {\n        const { intervalTreeMap } = await this.setup();\n        return Object.keys(intervalTreeMap);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            var _a;\n            try {\n                const { start, end, refName } = region;\n                const { intervalTreeMap } = await this.setup();\n                for (const f of ((_a = intervalTreeMap[refName]) === null || _a === void 0 ? void 0 : _a.call(intervalTreeMap, opts.statusCallback).search([\n                    start,\n                    end,\n                ])) || []) {\n                    observer.next(f);\n                }\n                observer.complete();\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    async getSources() {\n        const conf = this.getConf('samplesTsvLocation');\n        if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n            const { parser } = await this.setup();\n            return parser.samples.map(name => ({\n                name,\n            }));\n        }\n        else {\n            const txt = await openLocation(conf).readFile('utf8');\n            const lines = txt.split(/\\n|\\r\\n|\\r/);\n            const header = lines[0].split('\\t');\n            const { parser } = await this.setup();\n            const s = new Set(parser.samples);\n            return lines\n                .slice(1)\n                .map(line => {\n                const cols = line.split('\\t');\n                return {\n                    name: cols[0],\n                    ...Object.fromEntries(cols.slice(1).map((c, idx) => [header[idx + 1], c])),\n                };\n            })\n                .filter(f => s.has(f.name));\n        }\n    }\n}\nVcfAdapter.capabilities = ['getFeatures', 'getRefNames'];\nexport default VcfAdapter;\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","header","parser","opts","statusCallback","loc","openLocation","buffer","fetchAndMaybeUnzip","headerLines","featureMap","blockStart","decoder","i","n","b","line","ret","refName","getProgressDisplayStr","VcfParser","intervalTreeMap","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","e","_","region","ObservableCreate","observer","_a","start","end","conf","name","s","cols","c"],"mappings":"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","x_google_ignoreList":[0]}