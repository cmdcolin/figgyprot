import{cm as d,aV as b,ce as F,cn as I,aW as l,aX as L,aY as S,co as A}from"./index-CT2bM4yV.js";function x(r,e){return r.offset+r.lineBytes*Math.floor(e/r.lineLength)+e%r.lineLength}async function O(r,e){const s=new TextDecoder("utf8");return Object.fromEntries(s.decode(await r.readFile(e)).split(/\r?\n/).map(t=>t.trim()).filter(t=>!!t).map(t=>t.split("	")).map(t=>{var a;if((a=t[0])!=null&&a.startsWith(">"))throw new Error("found > in sequence name, might have supplied FASTA file for the FASTA index");return[t[0],{name:t[0],length:+t[1],start:0,end:+t[1],offset:+t[2],lineLength:+t[3],lineBytes:+t[4]}]}))}class k{constructor({fasta:e,fai:s,path:t,faiPath:a}){if(e)this.fasta=e;else if(t)this.fasta=new d(t);else throw new Error("Need to pass filehandle for fasta or path to localfile");if(s)this.fai=s;else if(a)this.fai=new d(a);else if(t)this.fai=new d(`${t}.fai`);else throw new Error("Need to pass filehandle for  or path to localfile")}async _getIndexes(e){return this.indexes||(this.indexes=O(this.fai,e).catch(s=>{throw this.indexes=void 0,s})),this.indexes}async getSequenceNames(e){return Object.keys(await this._getIndexes(e))}async getSequenceSizes(e){const s={},t=await this._getIndexes(e);for(const a of Object.values(t))s[a.name]=a.length;return s}async getSequenceSize(e,s){var a;return(a=(await this._getIndexes(s))[e])==null?void 0:a.length}async hasReferenceSequence(e,s){return!!(await this._getIndexes(s))[e]}async getResiduesByName(e,s,t,a){const n=(await this._getIndexes(a))[e];return n?this._fetchFromIndexEntry(n,s,t,a):void 0}async getSequence(e,s,t,a){return this.getResiduesByName(e,s,t,a)}async _fetchFromIndexEntry(e,s=0,t,a){let n=t;if(s<0)throw new TypeError("regionStart cannot be less than 0");if((n===void 0||n>e.length)&&(n=e.length),s>=n)return"";const i=x(e,s),c=x(e,n)-i;return new TextDecoder("utf8").decode(await this.fasta.read(c,i,a)).replace(/\s+/g,"")}}class z extends b.BaseSequenceAdapter{constructor(){super(...arguments),this.seqCache=new F({cache:new I({maxSize:200}),fill:async e=>{const{refName:s,start:t,end:a,fasta:n}=e;return n.getSequence(s,t,a)}})}async getRefNames(e){const{fasta:s}=await this.setup();return s.getSequenceNames()}async getRegions(e){const{fasta:s}=await this.setup(),t=await s.getSequenceSizes();return Object.keys(t).map(a=>({refName:a,start:0,end:t[a]}))}async setupPre(){const e=this.getConf("fastaLocation"),s=this.getConf("faiLocation");return{fasta:new k({fasta:l.openLocation(e,this.pluginManager),fai:l.openLocation(s,this.pluginManager)})}}async getHeader(){const e=this.getConf("metadataLocation");return e.uri===""||e.uri==="/path/to/fa.metadata.yaml"?null:l.openLocation(e,this.pluginManager).readFile("utf8")}async setup(){return this.setupP||(this.setupP=this.setupPre().catch(e=>{throw this.setupP=void 0,e})),this.setupP}getFeatures(e,s){const{statusCallback:t=()=>{},stopToken:a}=s||{},{refName:n,start:i,end:c}=e;return L(async f=>{await S.updateStatus2("Downloading sequence",t,a,async()=>{const{fasta:h}=await this.setup(),_=await h.getSequenceSize(n),g=Math.min(_||0,c),p=[],u=128e3,m=i-i%u,q=c+(u-c%u);for(let o=m;o<q;o+=u){const w={refName:n,start:o,end:o+u};A(a),p.push(await this.seqCache.get(JSON.stringify(w),{...w,fasta:h}))}const y=p.filter(o=>!!o).join("").slice(i-m).slice(0,c-i);y&&f.next(new S.SimpleFeature({id:`${n}-${i}-${g}`,data:{refName:n,start:i,end:g,seq:y}}))}),f.complete()})}freeResources(){}}const j=Object.freeze(Object.defineProperty({__proto__:null,default:z},Symbol.toStringTag,{value:"Module"}));export{k as I,z as a,j as b};
//# sourceMappingURL=IndexedFastaAdapter-C3V96IP4.js.map
