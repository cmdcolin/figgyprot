{"version":3,"file":"DeltaAdapter-dBI-qdiT.js","sources":["../../node_modules/@jbrowse/plugin-comparative-adapters/esm/DeltaAdapter/util.js","../../node_modules/@jbrowse/plugin-comparative-adapters/esm/DeltaAdapter/DeltaAdapter.js"],"sourcesContent":["import { getProgressDisplayStr } from '@jbrowse/core/util';\nexport function paf_delta2paf(buffer, opts) {\n    const { statusCallback = () => { } } = opts || {};\n    let rname = '';\n    let qname = '';\n    let qs = 0;\n    let qe = 0;\n    let rs = 0;\n    let re = 0;\n    let strand = 0;\n    let NM = 0;\n    let cigar = [];\n    let x = 0;\n    let y = 0;\n    let seen_gt = false;\n    const records = [];\n    const regex = new RegExp(/^>(\\S+)\\s+(\\S+)\\s+(\\d+)\\s+(\\d+)/);\n    let blockStart = 0;\n    let i = 0;\n    let j = 0;\n    const decoder = new TextDecoder('utf8');\n    while (blockStart < buffer.length) {\n        if (j++ % 10000 === 0) {\n            statusCallback(`Loading ${getProgressDisplayStr(blockStart, buffer.length)}`);\n        }\n        const n = buffer.indexOf(10, blockStart);\n        if (n === -1) {\n            break;\n        }\n        const b = buffer.subarray(blockStart, n);\n        const line = decoder.decode(b).trim();\n        blockStart = n + 1;\n        i++;\n        if (line) {\n            const m = regex.exec(line);\n            if (m !== null) {\n                rname = m[1];\n                qname = m[2];\n                seen_gt = true;\n                continue;\n            }\n            if (!seen_gt) {\n                continue;\n            }\n            const t = line.split(' ');\n            if (t.length === 7) {\n                const t0 = +t[0];\n                const t1 = +t[1];\n                const t2 = +t[2];\n                const t3 = +t[3];\n                const t4 = +t[4];\n                strand = (t0 < t1 && t2 < t3) || (t0 > t1 && t2 > t3) ? 1 : -1;\n                rs = +Math.min(t0, t1) - 1;\n                re = +Math.max(t1, t0);\n                qs = +Math.min(t2, t3) - 1;\n                qe = +Math.max(t3, t2);\n                x = y = 0;\n                NM = t4;\n                cigar = [];\n            }\n            else if (t.length === 1) {\n                const d = +t[0];\n                if (d === 0) {\n                    let blen = 0;\n                    const cigar_str = [];\n                    if (re - rs - x !== qe - qs - y) {\n                        throw new Error(`inconsistent alignment on line ${i}`);\n                    }\n                    cigar.push((re - rs - x) << 4);\n                    for (const entry of cigar) {\n                        const rlen = entry >> 4;\n                        blen += rlen;\n                        cigar_str.push(rlen + 'MID'.charAt(cigar[i] & 0xf));\n                    }\n                    records.push({\n                        qname,\n                        qstart: qs,\n                        qend: qe,\n                        tname: rname,\n                        tstart: rs,\n                        tend: re,\n                        strand,\n                        extra: {\n                            numMatches: blen - NM,\n                            blockLen: blen,\n                            mappingQual: 0,\n                            NM,\n                            cg: cigar_str.join(''),\n                        },\n                    });\n                }\n                else if (d > 0) {\n                    const l = d - 1;\n                    x += l + 1;\n                    y += l;\n                    if (l > 0) {\n                        cigar.push(l << 4);\n                    }\n                    if (cigar.length > 0 && (cigar[cigar.length - 1] & 0xf) === 2) {\n                        cigar[cigar.length - 1] += 1 << 4;\n                    }\n                    else {\n                        cigar.push((1 << 4) | 2);\n                    }\n                }\n                else {\n                    const l = -d - 1;\n                    x += l;\n                    y += l + 1;\n                    if (l > 0) {\n                        cigar.push(l << 4);\n                    }\n                    if (cigar.length > 0 && (cigar[cigar.length - 1] & 0xf) === 1) {\n                        cigar[cigar.length - 1] += 1 << 4;\n                    }\n                    else {\n                        cigar.push((1 << 4) | 1);\n                    }\n                }\n            }\n        }\n    }\n    return records;\n}\n","import { fetchAndMaybeUnzip } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { paf_delta2paf } from './util';\nimport PAFAdapter from '../PAFAdapter/PAFAdapter';\nexport default class DeltaAdapter extends PAFAdapter {\n    async setupPre(opts) {\n        const loc = openLocation(this.getConf('deltaLocation'), this.pluginManager);\n        const buf = await fetchAndMaybeUnzip(loc, opts);\n        return paf_delta2paf(buf);\n    }\n}\n"],"names":["paf_delta2paf","buffer","opts","statusCallback","rname","qname","qs","qe","rs","re","strand","NM","cigar","x","y","seen_gt","records","regex","blockStart","i","j","decoder","getProgressDisplayStr","n","b","line","m","t","t0","t1","t2","t3","t4","d","blen","cigar_str","entry","rlen","l","DeltaAdapter","PAFAdapter","loc","openLocation","buf","fetchAndMaybeUnzip"],"mappings":"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","x_google_ignoreList":[0,1]}