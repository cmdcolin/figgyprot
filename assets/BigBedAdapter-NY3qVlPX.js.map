{"version":3,"file":"BigBedAdapter-NY3qVlPX.js","sources":["../../node_modules/@gmod/bbi/esm/bigbed.js","../../node_modules/@jbrowse/plugin-bed/esm/BigBedAdapter/BigBedAdapter.js"],"sourcesContent":["import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from 'quick-lru';\nimport { Observable, firstValueFrom, merge } from 'rxjs';\nimport { map, reduce } from 'rxjs/operators';\nimport { BBI } from './bbi';\nexport function filterUndef(ts) {\n    return ts.filter((t) => !!t);\n}\nexport class BigBed extends BBI {\n    constructor() {\n        super(...arguments);\n        this.readIndicesCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 1 }),\n            fill: (args, signal) => this._readIndices({ ...args, signal }),\n        });\n    }\n    readIndices(opts = {}) {\n        const { signal, ...rest } = opts;\n        return this.readIndicesCache.get(JSON.stringify(rest), opts, signal);\n    }\n    /*\n     * retrieve unzoomed view for any scale\n     */\n    async getView(_scale, opts) {\n        return this.getUnzoomedView(opts);\n    }\n    /*\n     * parse the bigbed extraIndex fields\n     *\n     *\n     * @return a Promise for an array of Index data structure since there can be\n     * multiple extraIndexes in a bigbed, see bedToBigBed documentation\n     */\n    async _readIndices(opts) {\n        const { extHeaderOffset } = await this.getHeader(opts);\n        const b = await this.bbi.read(64, Number(extHeaderOffset));\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        // const _size = dataView.getUint16(offset, true)\n        offset += 2;\n        const count = dataView.getUint16(offset, true);\n        offset += 2;\n        const dataOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        // no extra index is defined if count==0\n        if (count === 0) {\n            return [];\n        }\n        const blocklen = 20;\n        const len = blocklen * count;\n        const buffer = await this.bbi.read(len, Number(dataOffset));\n        const indices = [];\n        for (let i = 0; i < count; i += 1) {\n            const b = buffer.subarray(i * blocklen);\n            const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n            let offset = 0;\n            const type = dataView.getInt16(offset, true);\n            offset += 2;\n            const fieldcount = dataView.getInt16(offset, true);\n            offset += 2;\n            const dataOffset = Number(dataView.getBigUint64(offset, true));\n            offset += 8 + 4; //4 skip\n            const field = dataView.getInt16(offset, true);\n            indices.push({ type, fieldcount, offset: Number(dataOffset), field });\n        }\n        return indices;\n    }\n    /*\n     * perform a search in the bigbed extraIndex to find which blocks in the\n     * bigbed data to look for the actual feature data\n     *\n     * @param name - the name to search for\n     *\n     * @param opts - a SearchOptions argument with optional signal\n     *\n     * @return a Promise for an array of bigbed block Loc entries\n     */\n    async searchExtraIndexBlocks(name, opts = {}) {\n        const indices = await this.readIndices(opts);\n        if (indices.length === 0) {\n            return [];\n        }\n        const decoder = new TextDecoder('utf8');\n        const locs = indices.map(async (index) => {\n            const { offset: offset2, field } = index;\n            const b = await this.bbi.read(32, offset2, opts);\n            const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n            let offset = 0;\n            // const _magic = dataView.getInt32(offset, true)\n            offset += 4;\n            const blockSize = dataView.getInt32(offset, true);\n            offset += 4;\n            const keySize = dataView.getInt32(offset, true);\n            offset += 4;\n            const valSize = dataView.getInt32(offset, true);\n            offset += 4;\n            // const _itemCount = Number(dataView.getBigUint64(offset, true))\n            offset += 8;\n            const bptReadNode = async (nodeOffset) => {\n                const val = Number(nodeOffset);\n                const len = 4 + blockSize * (keySize + valSize);\n                const buffer = await this.bbi.read(len, val, opts);\n                const b = buffer;\n                const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n                let offset = 0;\n                const nodeType = dataView.getInt8(offset);\n                offset += 2; //skip 1\n                const cnt = dataView.getInt16(offset, true);\n                offset += 2;\n                const keys = [];\n                if (nodeType === 0) {\n                    const leafkeys = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const key = decoder\n                            .decode(b.subarray(offset, offset + keySize))\n                            .replaceAll('\\0', '');\n                        offset += keySize;\n                        const dataOffset = Number(dataView.getBigUint64(offset, true));\n                        offset += 8;\n                        leafkeys.push({\n                            key,\n                            offset: dataOffset,\n                        });\n                    }\n                    let lastOffset = 0;\n                    for (const { key, offset } of leafkeys) {\n                        if (name.localeCompare(key) < 0 && lastOffset) {\n                            return bptReadNode(lastOffset);\n                        }\n                        lastOffset = offset;\n                    }\n                    return bptReadNode(lastOffset);\n                }\n                else if (nodeType === 1) {\n                    for (let i = 0; i < cnt; i++) {\n                        const key = decoder\n                            .decode(b.subarray(offset, offset + keySize))\n                            .replaceAll('\\0', '');\n                        offset += keySize;\n                        const dataOffset = Number(dataView.getBigUint64(offset, true));\n                        offset += 8;\n                        const length = dataView.getUint32(offset, true);\n                        offset += 4;\n                        const reserved = dataView.getUint32(offset, true);\n                        offset += 4;\n                        keys.push({\n                            key,\n                            offset: dataOffset,\n                            length,\n                            reserved,\n                        });\n                    }\n                    for (const n of keys) {\n                        if (n.key === name) {\n                            return { ...n, field };\n                        }\n                    }\n                    return undefined;\n                }\n            };\n            const rootNodeOffset = 32;\n            return bptReadNode(offset2 + rootNodeOffset);\n        });\n        return filterUndef(await Promise.all(locs));\n    }\n    /*\n     * retrieve the features from the bigbed data that were found through the\n     * lookup of the extraIndex note that there can be multiple extraIndex, see\n     * the BigBed specification and the -extraIndex argument to bedToBigBed\n     *\n     * @param name - the name to search for\n     *\n     * @param opts - options object with optional AboutSignal\n     *\n     * @return array of Feature\n     */\n    async searchExtraIndex(name, opts = {}) {\n        const blocks = await this.searchExtraIndexBlocks(name, opts);\n        if (blocks.length === 0) {\n            return [];\n        }\n        const view = await this.getUnzoomedView(opts);\n        const res = blocks.map(block => {\n            return new Observable(observer => {\n                view.readFeatures(observer, [block], opts).catch((e) => {\n                    observer.error(e);\n                });\n            }).pipe(reduce((acc, curr) => acc.concat(curr)), map(x => {\n                for (const element of x) {\n                    element.field = block.field;\n                }\n                return x;\n            }));\n        });\n        const ret = await firstValueFrom(merge(...res));\n        return ret.filter(f => f.rest?.split('\\t')[(f.field || 0) - 3] === name);\n    }\n}\n//# sourceMappingURL=bigbed.js.map","import { BigBed } from '@gmod/bbi';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, doesIntersect2, max, min, updateStatus, } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { firstValueFrom, toArray } from 'rxjs';\nimport { featureData2 } from '../util';\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n    async configurePre(opts) {\n        const pm = this.pluginManager;\n        const bigbed = new BigBed({\n            filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n        });\n        const header = await bigbed.getHeader(opts);\n        const parser = new BED({\n            autoSql: header.autoSql,\n        });\n        return {\n            bigbed,\n            header,\n            parser,\n        };\n    }\n    async configure(opts) {\n        if (!this.cachedP) {\n            this.cachedP = this.configurePre(opts).catch((e) => {\n                this.cachedP = undefined;\n                throw e;\n            });\n        }\n        return this.cachedP;\n    }\n    async getRefNames(opts) {\n        const { header } = await this.configure(opts);\n        return Object.keys(header.refsByName);\n    }\n    async getRefNameAliases(opts) {\n        const { header } = await this.configure(opts);\n        const ret = await Promise.all(Object.keys(header.refsByName).map(async (r) => (await firstValueFrom(this.getFeatures({\n            assemblyName: '',\n            refName: r,\n            start: 0,\n            end: 1,\n        }).pipe(toArray())))[0]));\n        return ret\n            .map(r => r.toJSON())\n            .map(r => ({\n            refName: r.ucsc,\n            aliases: [r.ncbi, r.refseq, r.genbank],\n            override: true,\n        }));\n    }\n    async getData() {\n        const refNames = await this.getRefNames();\n        const features = [];\n        for (const refName of refNames) {\n            const f = await firstValueFrom(this.getFeatures({\n                assemblyName: 'unknown',\n                refName,\n                start: 0,\n                end: Number.MAX_SAFE_INTEGER,\n            }).pipe(toArray()));\n            features.push(f);\n        }\n        return features.flat();\n    }\n    async getHeader(opts) {\n        const { parser, header } = await this.configure(opts);\n        const { version, fileType } = header;\n        const { fields, ...rest } = parser.autoSql;\n        return {\n            version,\n            fileType,\n            autoSql: { ...rest },\n            fields: Object.fromEntries(fields.map(({ name, comment }) => [name, comment])),\n        };\n    }\n    async getFeaturesHelper({ query, opts, observer, allowRedispatch, originalQuery = query, }) {\n        var _a;\n        const { statusCallback = () => { } } = opts;\n        const scoreColumn = this.getConf('scoreColumn');\n        const aggregateField = this.getConf('aggregateField');\n        const { parser, bigbed } = await updateStatus('Downloading header', statusCallback, () => this.configure(opts));\n        const feats = await updateStatus('Downloading features', statusCallback, () => bigbed.getFeatures(query.refName, query.start, query.end, {\n            basesPerSpan: query.end - query.start,\n        }));\n        if (allowRedispatch && feats.length) {\n            let minStart = Number.POSITIVE_INFINITY;\n            let maxEnd = Number.NEGATIVE_INFINITY;\n            let hasAnyAggregationField = false;\n            for (const feat of feats) {\n                if (feat.start < minStart) {\n                    minStart = feat.start;\n                }\n                if (feat.end > maxEnd) {\n                    maxEnd = feat.end;\n                }\n                if (feat[aggregateField]) {\n                    hasAnyAggregationField = true;\n                }\n            }\n            if (hasAnyAggregationField &&\n                (maxEnd > query.end || minStart < query.start)) {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: minStart - 500000,\n                        end: maxEnd + 500000,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: false,\n                    originalQuery: query,\n                });\n                return;\n            }\n        }\n        const parentAggregation = {};\n        if (feats.some(f => f.uniqueId === undefined)) {\n            throw new Error('found uniqueId undefined');\n        }\n        for (const feat of feats) {\n            const splitLine = [\n                query.refName,\n                `${feat.start}`,\n                `${feat.end}`,\n                ...(((_a = feat.rest) === null || _a === void 0 ? void 0 : _a.split('\\t')) || []),\n            ];\n            const data = parser.parseLine(splitLine, {\n                uniqueId: feat.uniqueId,\n            });\n            const aggr = data[aggregateField];\n            if (!parentAggregation[aggr]) {\n                parentAggregation[aggr] = [];\n            }\n            const { uniqueId, type, chrom, chromStart, chromEnd, description, chromStarts: chromStarts2, blockStarts: blockStarts2, blockSizes: blockSizes2, score: score2, blockCount, thickStart, thickEnd, strand, ...rest } = data;\n            const f = featureData2({\n                ...rest,\n                scoreColumn,\n                splitLine,\n                parser,\n                uniqueId,\n                start: feat.start,\n                end: feat.end,\n                refName: query.refName,\n            });\n            if (aggr) {\n                parentAggregation[aggr].push(f);\n            }\n            else {\n                if (doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)) {\n                    observer.next(new SimpleFeature({\n                        id: `${this.id}-${uniqueId}`,\n                        data: f,\n                    }));\n                }\n            }\n        }\n        Object.entries(parentAggregation).map(([name, subfeatures]) => {\n            var _a, _b;\n            const s = min(subfeatures.map(f => f.start));\n            const e = max(subfeatures.map(f => f.end));\n            if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n                const subs = subfeatures.sort((a, b) => a.uniqueId.localeCompare(b.uniqueId));\n                observer.next(new SimpleFeature({\n                    id: `${this.id}-${(_a = subs[0]) === null || _a === void 0 ? void 0 : _a.uniqueId}-parent`,\n                    data: {\n                        type: 'gene',\n                        subfeatures: subs,\n                        strand: ((_b = subs[0]) === null || _b === void 0 ? void 0 : _b.strand) || 1,\n                        name,\n                        start: s,\n                        end: e,\n                        refName: query.refName,\n                    },\n                }));\n            }\n        });\n        observer.complete();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            try {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: query.start,\n                        end: query.end,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: true,\n                });\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    freeResources() { }\n}\n"],"names":["filterUndef","ts","t","BigBed","BBI","AbortablePromiseCache","QuickLRU","args","signal","opts","rest","_scale","extHeaderOffset","b","dataView","offset","count","dataOffset","blocklen","len","buffer","indices","i","type","fieldcount","field","name","decoder","locs","index","offset2","blockSize","keySize","valSize","bptReadNode","nodeOffset","val","nodeType","cnt","keys","leafkeys","key","lastOffset","length","reserved","n","blocks","view","res","block","Observable","observer","e","reduce","acc","curr","map","x","element","firstValueFrom","merge","f","_a","BigBedAdapter","BaseFeatureDataAdapter","pm","bigbed","openLocation","header","parser","BED","r","toArray","refNames","features","refName","version","fileType","fields","comment","query","allowRedispatch","originalQuery","statusCallback","scoreColumn","aggregateField","updateStatus","feats","minStart","maxEnd","hasAnyAggregationField","feat","parentAggregation","splitLine","data","aggr","uniqueId","chrom","chromStart","chromEnd","description","chromStarts2","blockStarts2","blockSizes2","score2","blockCount","thickStart","thickEnd","strand","featureData2","doesIntersect2","SimpleFeature","subfeatures","_b","s","min","max","subs","a","ObservableCreate"],"mappings":"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","x_google_ignoreList":[0,1]}