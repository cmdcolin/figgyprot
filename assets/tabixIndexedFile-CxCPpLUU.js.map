{"version":3,"file":"tabixIndexedFile-CxCPpLUU.js","sources":["../../node_modules/@gmod/tabix/esm/util.js","../../node_modules/@gmod/tabix/esm/virtualOffset.js","../../node_modules/@gmod/tabix/esm/chunk.js","../../node_modules/@gmod/tabix/esm/indexFile.js","../../node_modules/@gmod/tabix/esm/long.js","../../node_modules/@gmod/tabix/esm/tbi.js","../../node_modules/@gmod/tabix/esm/csi.js","../../node_modules/@gmod/tabix/esm/tabixIndexedFile.js"],"sourcesContent":["class AbortError extends Error {\n}\n/**\n * Properly check if the given AbortSignal is aborted. Per the standard, if the\n * signal reads as aborted, this function throws either a DOMException\n * AbortError, or a regular error with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted`\n * attribute\n *\n * @returns nothing\n */\nexport function checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        if (typeof DOMException !== 'undefined') {\n            throw new DOMException('aborted', 'AbortError');\n        }\n        else {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n    }\n}\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexport function canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexport function optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk = null;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort(function (c0, c1) {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        return dif !== 0 ? dif : c0.minv.dataPosition - c1.minv.dataPosition;\n    });\n    chunks.forEach(chunk => {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === null) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    });\n    return mergedChunks;\n}\n//# sourceMappingURL=util.js.map","export default class VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n}\nexport function fromBytes(bytes, offset = 0) {\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\n//# sourceMappingURL=virtualOffset.js.map","// little class representing a chunk in the index\nexport default class Chunk {\n    constructor(minv, maxv, bin, fetchedSize = undefined) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\n//# sourceMappingURL=chunk.js.map","export default class IndexFile {\n    constructor({ filehandle, renameRefSeqs = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeqs;\n    }\n    async getMetadata(opts = {}) {\n        const { indices: _indices, ...rest } = await this.parse(opts);\n        return rest;\n    }\n    _findFirstData(currentFdl, virtualOffset) {\n        if (currentFdl) {\n            return currentFdl.compareTo(virtualOffset) > 0\n                ? virtualOffset\n                : currentFdl;\n        }\n        else {\n            return virtualOffset;\n        }\n    }\n    async parse(opts = {}) {\n        if (!this.parseP) {\n            this.parseP = this._parse(opts).catch((e) => {\n                this.parseP = undefined;\n                throw e;\n            });\n        }\n        return this.parseP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        const idx = await this.parse(opts);\n        return !!idx.indices[seqId]?.binIndex;\n    }\n}\n//# sourceMappingURL=indexFile.js.map","export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","import VirtualOffset, { fromBytes } from './virtualOffset';\nimport Chunk from './chunk';\nimport { unzip } from '@gmod/bgzf-filehandle';\nimport { optimizeChunks, checkAbortSignal } from './util';\nimport IndexFile from './indexFile';\nimport { longFromBytesToUnsigned } from './long';\nconst TBI_MAGIC = 21578324; // TBI\\1\nconst TAD_LIDX_SHIFT = 14;\n/**\n * calculate the list of bins that may overlap with region [beg,end)\n * (zero-based half-open)\n */\nfunction reg2bins(beg, end) {\n    beg += 1; // < convert to 1-based closed\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nexport default class TabixIndex extends IndexFile {\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return -1;\n        }\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        return indexData.indices[refId].stats?.lineCount ?? -1;\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const buf = await this.filehandle.readFile(opts);\n        const bytes = await unzip(buf);\n        checkAbortSignal(opts.signal);\n        const dataView = new DataView(bytes.buffer);\n        const magic = dataView.getUint32(0, true);\n        if (magic !== TBI_MAGIC /* \"TBI\\1\" */) {\n            throw new Error('Not a TBI file');\n        }\n        // number of reference sequences in the index\n        const refCount = dataView.getUint32(4, true);\n        const formatFlags = dataView.getUint32(8, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const formatOpts = {\n            0: 'generic',\n            1: 'SAM',\n            2: 'VCF',\n        };\n        const format = formatOpts[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(12, true),\n            start: dataView.getInt32(16, true),\n            end: dataView.getInt32(20, true),\n        };\n        const metaValue = dataView.getInt32(24, true);\n        const depth = 5;\n        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (14 + depth * 3);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;\n        const skipLines = dataView.getInt32(28, true);\n        // read sequence dictionary\n        const nameSectionLength = dataView.getInt32(32, true);\n        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));\n        // read the indexes for each reference sequence\n        let currOffset = 36 + nameSectionLength;\n        let firstDataLine;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(currOffset, true);\n                currOffset += 4;\n                if (bin > maxBinNumber + 1) {\n                    throw new Error('tabix index contains too many bins, please use a CSI index');\n                }\n                else if (bin === maxBinNumber + 1) {\n                    const chunkCount = dataView.getInt32(currOffset, true);\n                    currOffset += 4;\n                    if (chunkCount === 2) {\n                        stats = this.parsePseudoBin(bytes, currOffset);\n                    }\n                    currOffset += 16 * chunkCount;\n                }\n                else {\n                    const chunkCount = dataView.getInt32(currOffset, true);\n                    currOffset += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, currOffset);\n                        const v = fromBytes(bytes, currOffset + 8);\n                        currOffset += 16;\n                        firstDataLine = this._findFirstData(firstDataLine, u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            // the linear index\n            const linearCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const linearIndex = new Array(linearCount);\n            for (let k = 0; k < linearCount; k += 1) {\n                linearIndex[k] = fromBytes(bytes, currOffset);\n                currOffset += 8;\n                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);\n            }\n            return {\n                binIndex,\n                linearIndex,\n                stats,\n            };\n        });\n        return {\n            indices,\n            metaChar,\n            maxBinNumber,\n            maxRefLength,\n            skipLines,\n            firstDataLine,\n            columnNumbers,\n            coordinateType,\n            format,\n            refIdToName,\n            refNameToId,\n            maxBlockSize: 1 << 16,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        return {\n            lineCount: longFromBytesToUnsigned(bytes, offset + 16),\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return {\n            refNameToId,\n            refIdToName,\n        };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        const minOffset = ba.linearIndex.length\n            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length\n                ? ba.linearIndex.length - 1\n                : min >> TAD_LIDX_SHIFT]\n            : new VirtualOffset(0, 0);\n        if (!minOffset) {\n            console.warn('querying outside of possible tabix range');\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    for (const c of ba.binIndex[bin]) {\n                        chunks.push(new Chunk(c.minv, c.maxv, bin));\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest = null;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp) {\n                if (!lowest || vp.compareTo(lowest) < 0) {\n                    lowest = vp;\n                }\n            }\n        }\n        return optimizeChunks(chunks, lowest);\n    }\n}\n//# sourceMappingURL=tbi.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport VirtualOffset, { fromBytes } from './virtualOffset';\nimport Chunk from './chunk';\nimport { optimizeChunks } from './util';\nimport IndexFile from './indexFile';\nimport { longFromBytesToUnsigned } from './long';\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nconst formats = {\n    0: 'generic',\n    1: 'SAM',\n    2: 'VCF',\n};\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nexport default class CSI extends IndexFile {\n    constructor(args) {\n        super(args);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return -1;\n        }\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    indexCov() {\n        throw new Error('CSI indexes do not support indexcov');\n    }\n    parseAuxData(bytes, offset) {\n        const dataView = new DataView(bytes.buffer);\n        const formatFlags = dataView.getInt32(offset, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = formats[(formatFlags & 0xf)];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(offset + 4, true),\n            start: dataView.getInt32(offset + 8, true),\n            end: dataView.getInt32(offset + 12, true),\n        };\n        const metaValue = dataView.getInt32(offset + 16, true);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;\n        const skipLines = dataView.getInt32(offset + 20, true);\n        const nameSectionLength = dataView.getInt32(offset + 24, true);\n        const { refIdToName, refNameToId } = this._parseNameBytes(bytes.subarray(offset + 28, offset + 28 + nameSectionLength));\n        return {\n            refIdToName,\n            refNameToId,\n            skipLines,\n            metaChar,\n            columnNumbers,\n            format,\n            coordinateType,\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return {\n            refNameToId,\n            refIdToName,\n        };\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const bytes = await unzip(await this.filehandle.readFile(opts));\n        const dataView = new DataView(bytes.buffer);\n        // check TBI magic numbers\n        let csiVersion;\n        if (dataView.getUint32(0, true) === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (dataView.getUint32(0, true) === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error('Not a CSI file');\n        }\n        this.minShift = dataView.getInt32(4, true);\n        this.depth = dataView.getInt32(8, true);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (this.minShift + this.depth * 3);\n        const auxLength = dataView.getInt32(12, true);\n        const aux = auxLength && auxLength >= 30\n            ? this.parseAuxData(bytes, 16)\n            : {\n                refIdToName: [],\n                refNameToId: {},\n                metaChar: null,\n                columnNumbers: { ref: 0, start: 1, end: 2 },\n                coordinateType: 'zero-based-half-open',\n                format: 'generic',\n            };\n        const refCount = dataView.getInt32(16 + auxLength, true);\n        // read the indexes for each reference sequence\n        let firstDataLine;\n        let currOffset = 16 + auxLength + 4;\n        const indices = new Array(refCount).fill(0).map(() => {\n            const binCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(currOffset, true);\n                if (bin > this.maxBinNumber) {\n                    // this is a fake bin that actually has stats information about the\n                    // reference sequence in it\n                    stats = this.parsePseudoBin(bytes, currOffset + 4);\n                    currOffset += 4 + 8 + 4 + 16 + 16;\n                }\n                else {\n                    const loffset = fromBytes(bytes, currOffset + 4);\n                    firstDataLine = this._findFirstData(firstDataLine, loffset);\n                    const chunkCount = dataView.getInt32(currOffset + 12, true);\n                    currOffset += 16;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, currOffset);\n                        const v = fromBytes(bytes, currOffset + 8);\n                        currOffset += 16;\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            return { binIndex, stats };\n        });\n        return {\n            ...aux,\n            csi: true,\n            refCount,\n            maxBlockSize: 1 << 16,\n            firstDataLine,\n            csiVersion,\n            indices,\n            depth: this.depth,\n            maxBinNumber: this.maxBinNumber,\n            maxRefLength,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        return {\n            lineCount: longFromBytesToUnsigned(bytes, offset + 28),\n        };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        // List of bin #s that overlap min, max\n        const overlappingBins = this.reg2bins(min, max);\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    for (const c of ba.binIndex[bin]) {\n                        chunks.push(new Chunk(c.minv, c.maxv, bin));\n                    }\n                }\n            }\n        }\n        return optimizeChunks(chunks, new VirtualOffset(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n}\n//# sourceMappingURL=csi.js.map","import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport LRU from 'quick-lru';\nimport { RemoteFile, LocalFile } from 'generic-filehandle2';\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle';\nimport { checkAbortSignal } from './util';\nimport TBI from './tbi';\nimport CSI from './csi';\nfunction isASCII(str) {\n    // eslint-disable-next-line no-control-regex\n    return /^[\\u0000-\\u007F]*$/.test(str);\n}\nexport default class TabixIndexedFile {\n    /**\n     * @param {object} args\n     *\n     * @param {string} [args.path]\n     *\n     * @param {filehandle} [args.filehandle]\n     *\n     * @param {string} [args.tbiPath]\n     *\n     * @param {filehandle} [args.tbiFilehandle]\n     *\n     * @param {string} [args.csiPath]\n     *\n     * @param {filehandle} [args.csiFilehandle]\n     *\n     * @param {url} [args.url]\n     *\n     * @param {csiUrl} [args.csiUrl]\n     *\n     * @param {tbiUrl} [args.tbiUrl]\n     *\n     * @param {function} [args.renameRefSeqs] optional function with sig `string\n     * => string` to transform reference sequence names for the purpose of\n     * indexing and querying. note that the data that is returned is not altered,\n     * just the names of the reference sequences that are used for querying.\n     */\n    constructor({ path, filehandle, url, tbiPath, tbiUrl, tbiFilehandle, csiPath, csiUrl, csiFilehandle, renameRefSeqs = n => n, chunkCacheSize = 5 * 2 ** 20, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else if (url) {\n            this.filehandle = new RemoteFile(url);\n        }\n        else {\n            throw new TypeError('must provide either filehandle or path');\n        }\n        if (tbiFilehandle) {\n            this.index = new TBI({\n                filehandle: tbiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (csiFilehandle) {\n            this.index = new CSI({\n                filehandle: csiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (tbiPath) {\n            this.index = new TBI({\n                filehandle: new LocalFile(tbiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (csiPath) {\n            this.index = new CSI({\n                filehandle: new LocalFile(csiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (path) {\n            this.index = new TBI({\n                filehandle: new LocalFile(`${path}.tbi`),\n                renameRefSeqs,\n            });\n        }\n        else if (csiUrl) {\n            this.index = new CSI({\n                filehandle: new RemoteFile(csiUrl),\n            });\n        }\n        else if (tbiUrl) {\n            this.index = new TBI({\n                filehandle: new RemoteFile(tbiUrl),\n            });\n        }\n        else if (url) {\n            this.index = new TBI({\n                filehandle: new RemoteFile(`${url}.tbi`),\n            });\n        }\n        else {\n            throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl');\n        }\n        this.renameRefSeq = renameRefSeqs;\n        this.chunkCache = new AbortablePromiseCache({\n            cache: new LRU({ maxSize: Math.floor(chunkCacheSize / (1 << 16)) }),\n            fill: (args, signal) => this.readChunk(args, { signal }),\n        });\n    }\n    /**\n     * @param refName name of the reference sequence\n     *\n     * @param start start of the region (in 0-based half-open coordinates)\n     *\n     * @param end end of the region (in 0-based half-open coordinates)\n     *\n     * @param opts callback called for each line in the region. can also pass a\n     * object param containing obj.lineCallback, obj.signal, etc\n     *\n     * @returns promise that is resolved when the whole read is finished,\n     * rejected on error\n     */\n    async getLines(refName, s, e, opts) {\n        let signal;\n        let options = {};\n        let callback;\n        if (typeof opts === 'function') {\n            callback = opts;\n        }\n        else {\n            options = opts;\n            callback = opts.lineCallback;\n            signal = opts.signal;\n        }\n        const metadata = await this.index.getMetadata(options);\n        checkAbortSignal(signal);\n        const start = s ?? 0;\n        const end = e ?? metadata.maxRefLength;\n        if (!(start <= end)) {\n            throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');\n        }\n        if (start === end) {\n            return;\n        }\n        const chunks = await this.index.blocksForRange(refName, start, end, options);\n        checkAbortSignal(signal);\n        const decoder = new TextDecoder('utf8');\n        // now go through each chunk and parse and filter the lines out of it\n        for (const c of chunks) {\n            const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c, signal);\n            checkAbortSignal(signal);\n            let blockStart = 0;\n            let pos = 0;\n            // fast path, Buffer is just ASCII chars and not gigantor, can be\n            // converted to string and processed directly. if it is not ASCII or\n            // gigantic (chrome max str len is 512Mb), we have to decode line by line\n            const str = decoder.decode(buffer);\n            const strIsASCII = isASCII(str);\n            while (blockStart < str.length) {\n                let line;\n                let n;\n                if (strIsASCII) {\n                    n = str.indexOf('\\n', blockStart);\n                    if (n === -1) {\n                        break;\n                    }\n                    line = str.slice(blockStart, n);\n                }\n                else {\n                    n = buffer.indexOf('\\n'.charCodeAt(0), blockStart);\n                    if (n === -1) {\n                        break;\n                    }\n                    const b = buffer.slice(blockStart, n);\n                    line = decoder.decode(b);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (dpositions) {\n                    while (blockStart + c.minv.dataPosition >= dpositions[pos++]) { }\n                    pos--;\n                }\n                // filter the line for whether it is within the requested range\n                const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);\n                if (overlaps) {\n                    callback(line, \n                    // cpositions[pos] refers to actual file offset of a bgzip block\n                    // boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a\n                    // \"unique\" address space so that data in that block could never\n                    // overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset\n                    // from that bgzip block boundary, and since the cpositions are\n                    // multiplied by (1 << 8) these uncompressed offsets get a unique\n                    // space\n                    cpositions[pos] * (1 << 8) +\n                        (blockStart - dpositions[pos]) +\n                        c.minv.dataPosition +\n                        1);\n                }\n                else if (startCoordinate !== undefined && startCoordinate >= end) {\n                    // the lines were overlapping the region, but now have stopped, so we\n                    // must be at the end of the relevant data and we can stop processing\n                    // data now\n                    return;\n                }\n                blockStart = n + 1;\n            }\n        }\n    }\n    async getMetadata(opts = {}) {\n        return this.index.getMetadata(opts);\n    }\n    /**\n     * get a buffer containing the \"header\" region of the file, which are the\n     * bytes up to the first non-meta line\n     */\n    async getHeaderBuffer(opts = {}) {\n        const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);\n        checkAbortSignal(opts.signal);\n        const maxFetch = (firstDataLine?.blockPosition || 0) + maxBlockSize;\n        // TODO: what if we don't have a firstDataLine, and the header actually\n        // takes up more than one block? this case is not covered here\n        const buf = await this.filehandle.read(maxFetch, 0, opts);\n        const bytes = await unzip(buf);\n        // trim off lines after the last non-meta line\n        if (metaChar) {\n            // trim backward from the end\n            let lastNewline = -1;\n            const newlineByte = '\\n'.charCodeAt(0);\n            const metaByte = metaChar.charCodeAt(0);\n            for (let i = 0; i < bytes.length; i += 1) {\n                if (i === lastNewline + 1 && bytes[i] !== metaByte) {\n                    break;\n                }\n                if (bytes[i] === newlineByte) {\n                    lastNewline = i;\n                }\n            }\n            return bytes.subarray(0, lastNewline + 1);\n        }\n        return bytes;\n    }\n    /**\n     * get a string containing the \"header\" region of the file, is the portion up\n     * to the first non-meta line\n     *\n     * @returns {Promise} for a string\n     */\n    async getHeader(opts = {}) {\n        const decoder = new TextDecoder('utf8');\n        const bytes = await this.getHeaderBuffer(opts);\n        return decoder.decode(bytes);\n    }\n    /**\n     * get an array of reference sequence names, in the order in which they occur\n     * in the file. reference sequence renaming is not applied to these names.\n     */\n    async getReferenceSequenceNames(opts = {}) {\n        const metadata = await this.getMetadata(opts);\n        return metadata.refIdToName;\n    }\n    /**\n     * @param {object} metadata metadata object from the parsed index, containing\n     * columnNumbers, metaChar, and format\n     *\n     * @param {string} regionRefName\n     *\n     * @param {number} regionStart region start coordinate (0-based-half-open)\n     *\n     * @param {number} regionEnd region end coordinate (0-based-half-open)\n     *\n     * @param {array[string]} line\n     *\n     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,\n     * true if line is a data line that overlaps the given region\n     */\n    checkLine(metadata, regionRefName, regionStart, regionEnd, line) {\n        const { columnNumbers, metaChar, coordinateType, format } = metadata;\n        // skip meta lines\n        if (metaChar && line.startsWith(metaChar)) {\n            return { overlaps: false };\n        }\n        // check ref/start/end using column metadata from index\n        let { ref, start, end } = columnNumbers;\n        if (!ref) {\n            ref = 0;\n        }\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = 0;\n        }\n        if (format === 'VCF') {\n            end = 8;\n        }\n        const maxColumn = Math.max(ref, start, end);\n        // this code is kind of complex, but it is fairly fast. basically, we want\n        // to avoid doing a split, because if the lines are really long that could\n        // lead to us allocating a bunch of extra memory, which is slow\n        let currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata\n        let currentColumnStart = 0;\n        let refSeq = '';\n        let startCoordinate = -Infinity;\n        const l = line.length;\n        for (let i = 0; i < l + 1; i++) {\n            if (line[i] === '\\t' || i === l) {\n                if (currentColumnNumber === ref) {\n                    if (this.renameRefSeq(line.slice(currentColumnStart, i)) !==\n                        regionRefName) {\n                        return {\n                            overlaps: false,\n                        };\n                    }\n                }\n                else if (currentColumnNumber === start) {\n                    startCoordinate = parseInt(line.slice(currentColumnStart, i), 10);\n                    // we convert to 0-based-half-open\n                    if (coordinateType === '1-based-closed') {\n                        startCoordinate -= 1;\n                    }\n                    if (startCoordinate >= regionEnd) {\n                        return {\n                            startCoordinate,\n                            overlaps: false,\n                        };\n                    }\n                    if (end === 0 || end === start) {\n                        // if we have no end, we assume the feature is 1 bp long\n                        if (startCoordinate + 1 <= regionStart) {\n                            return {\n                                startCoordinate,\n                                overlaps: false,\n                            };\n                        }\n                    }\n                }\n                else if (format === 'VCF' && currentColumnNumber === 4) {\n                    refSeq = line.slice(currentColumnStart, i);\n                }\n                else if (currentColumnNumber === end) {\n                    // this will never match if there is no end column\n                    const endCoordinate = format === 'VCF'\n                        ? this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i))\n                        : Number.parseInt(line.slice(currentColumnStart, i), 10);\n                    if (endCoordinate <= regionStart) {\n                        return {\n                            overlaps: false,\n                        };\n                    }\n                }\n                currentColumnStart = i + 1;\n                currentColumnNumber += 1;\n                if (currentColumnNumber > maxColumn) {\n                    break;\n                }\n            }\n        }\n        return {\n            startCoordinate,\n            overlaps: true,\n        };\n    }\n    _getVcfEnd(startCoordinate, refSeq, info) {\n        let endCoordinate = startCoordinate + refSeq.length;\n        // ignore TRA features as they specify CHR2 and END as being on a different\n        // chromosome\n        //\n        // if CHR2 is on the same chromosome, still ignore it because there should\n        // be another pairwise feature at the end of this one\n        const isTRA = info.includes('SVTYPE=TRA');\n        if (info[0] !== '.' && !isTRA) {\n            let prevChar = ';';\n            for (let j = 0; j < info.length; j += 1) {\n                if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {\n                    let valueEnd = info.indexOf(';', j);\n                    if (valueEnd === -1) {\n                        valueEnd = info.length;\n                    }\n                    endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10);\n                    break;\n                }\n                prevChar = info[j];\n            }\n        }\n        else if (isTRA) {\n            return startCoordinate + 1;\n        }\n        return endCoordinate;\n    }\n    /**\n     * return the approximate number of data lines in the given reference\n     * sequence\n     *\n     * @param refSeq reference sequence name\n     *\n     * @returns number of data lines present on that reference sequence\n     */\n    async lineCount(refName, opts = {}) {\n        return this.index.lineCount(refName, opts);\n    }\n    /**\n     * read and uncompress the data in a chunk (composed of one or more\n     * contiguous bgzip blocks) of the file\n     */\n    async readChunk(c, opts = {}) {\n        const ret = await this.filehandle.read(c.fetchedSize(), c.minv.blockPosition, opts);\n        return unzipChunkSlice(ret, c);\n    }\n}\n//# sourceMappingURL=tabixIndexedFile.js.map"],"names":["AbortError","checkAbortSignal","signal","canMergeBlocks","chunk1","chunk2","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","c0","c1","dif","chunk","VirtualOffset","blockPosition","dataPosition","b","fromBytes","bytes","offset","Chunk","minv","maxv","bin","fetchedSize","IndexFile","filehandle","renameRefSeqs","opts","_indices","rest","currentFdl","virtualOffset","e","seqId","_a","TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","TBI_MAGIC","TAD_LIDX_SHIFT","reg2bins","beg","end","TabixIndex","refName","indexData","refId","buf","unzip","dataView","refCount","formatFlags","coordinateType","format","columnNumbers","metaValue","depth","maxBinNumber","maxRefLength","metaChar","skipLines","nameSectionLength","refNameToId","refIdToName","currOffset","firstDataLine","binCount","binIndex","stats","j","chunkCount","k","u","v","linearCount","linearIndex","namesBytes","currRefId","currNameStart","decoder","min","max","ba","overlappingBins","start","c","nintv","minLin","maxLin","vp","CSI1_MAGIC","CSI2_MAGIC","formats","lshift","num","bits","rshift","CSI","args","csiVersion","auxLength","aux","indices","loffset","l","t","s","bins","isASCII","str","TabixIndexedFile","path","url","tbiPath","tbiUrl","tbiFilehandle","csiPath","csiUrl","csiFilehandle","n","chunkCacheSize","LocalFile","RemoteFile","TBI","AbortablePromiseCache","LRU","options","callback","metadata","buffer","cpositions","dpositions","blockStart","pos","strIsASCII","line","startCoordinate","overlaps","maxBlockSize","maxFetch","lastNewline","newlineByte","metaByte","regionRefName","regionStart","regionEnd","ref","maxColumn","currentColumnNumber","currentColumnStart","refSeq","info","endCoordinate","isTRA","prevChar","valueEnd","ret","unzipChunkSlice"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}