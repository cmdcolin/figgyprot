{"version":3,"file":"index-DxWXH1qf.js","sources":["../../node_modules/generic-filehandle/esm/remoteFile.js","../../node_modules/generic-filehandle/esm/blobFile.js","../../node_modules/generic-filehandle/esm/index.js","../../node_modules/@jbrowse/core/data_adapters/BaseAdapter/util.js","../../node_modules/@jbrowse/core/data_adapters/BaseAdapter/types.js","../../node_modules/@jbrowse/core/util/idMaker.js","../../node_modules/@jbrowse/core/data_adapters/BaseAdapter/BaseAdapter.js","../../node_modules/@jbrowse/core/util/rxjs.js","../../node_modules/@jbrowse/core/util/stats.js","../../node_modules/@jbrowse/core/data_adapters/BaseAdapter/BaseFeatureDataAdapter.js","../../node_modules/@jbrowse/core/data_adapters/BaseAdapter/BaseSequenceAdapter.js","../../node_modules/@jbrowse/core/data_adapters/BaseAdapter/index.js","../../node_modules/@gmod/http-range-fetcher/esm/cacheSemantics.js","../../node_modules/@gmod/http-range-fetcher/esm/aggregatingFetcher.js","../../node_modules/@gmod/http-range-fetcher/esm/crossFetchBinaryRange.js","../../node_modules/@gmod/http-range-fetcher/esm/httpRangeFetcher.js","../../node_modules/@jbrowse/core/util/io/RemoteFileWithRangeCache.js","../../node_modules/@jbrowse/core/util/io/index.js"],"sourcesContent":["import { Buffer } from 'buffer';\nfunction getMessage(e) {\n    const r = typeof e === 'object' && e !== null && 'message' in e\n        ? e.message\n        : `${e}`;\n    return r.replace(/\\.$/, '');\n}\nexport default class RemoteFile {\n    async getBufferFromResponse(response) {\n        const resp = await response.arrayBuffer();\n        return Buffer.from(resp);\n    }\n    constructor(source, opts = {}) {\n        this.baseOverrides = {};\n        this.url = source;\n        const fetch = opts.fetch || globalThis.fetch.bind(globalThis);\n        if (!fetch) {\n            throw new TypeError(`no fetch function supplied, and none found in global environment`);\n        }\n        if (opts.overrides) {\n            this.baseOverrides = opts.overrides;\n        }\n        this.fetchImplementation = fetch;\n    }\n    async fetch(input, init) {\n        let response;\n        try {\n            response = await this.fetchImplementation(input, init);\n        }\n        catch (e) {\n            if (`${e}`.includes('Failed to fetch')) {\n                // refetch to to help work around a chrome bug (discussed in\n                // generic-filehandle issue #72) in which the chrome cache returns a\n                // CORS error for content in its cache.  see also\n                // https://github.com/GMOD/jbrowse-components/pull/1511\n                console.warn(`generic-filehandle: refetching ${input} to attempt to work around chrome CORS header caching bug`);\n                try {\n                    response = await this.fetchImplementation(input, {\n                        ...init,\n                        cache: 'reload',\n                    });\n                }\n                catch (e) {\n                    throw new Error(`${getMessage(e)} fetching ${input}`, { cause: e });\n                }\n            }\n            else {\n                throw new Error(`${getMessage(e)} fetching ${input}`, { cause: e });\n            }\n        }\n        return response;\n    }\n    async read(buffer, offset = 0, length, position = 0, opts = {}) {\n        const { headers = {}, signal, overrides = {} } = opts;\n        if (length < Infinity) {\n            headers.range = `bytes=${position}-${position + length}`;\n        }\n        else if (length === Infinity && position !== 0) {\n            headers.range = `bytes=${position}-`;\n        }\n        const res = await this.fetch(this.url, {\n            ...this.baseOverrides,\n            ...overrides,\n            headers: {\n                ...headers,\n                ...overrides.headers,\n                ...this.baseOverrides.headers,\n            },\n            method: 'GET',\n            redirect: 'follow',\n            mode: 'cors',\n            signal,\n        });\n        if (!res.ok) {\n            throw new Error(`HTTP ${res.status} fetching ${this.url}`);\n        }\n        if ((res.status === 200 && position === 0) || res.status === 206) {\n            const resData = await this.getBufferFromResponse(res);\n            const bytesCopied = resData.copy(buffer, offset, 0, Math.min(length, resData.length));\n            // try to parse out the size of the remote file\n            const contentRange = res.headers.get('content-range');\n            const sizeMatch = /\\/(\\d+)$/.exec(contentRange || '');\n            if (sizeMatch === null || sizeMatch === void 0 ? void 0 : sizeMatch[1]) {\n                this._stat = { size: parseInt(sizeMatch[1], 10) };\n            }\n            return { bytesRead: bytesCopied, buffer };\n        }\n        if (res.status === 200) {\n            throw new Error(`${this.url} fetch returned status 200, expected 206`);\n        }\n        // TODO: try harder here to gather more information about what the problem is\n        throw new Error(`HTTP ${res.status} fetching ${this.url}`);\n    }\n    async readFile(options = {}) {\n        let encoding;\n        let opts;\n        if (typeof options === 'string') {\n            encoding = options;\n            opts = {};\n        }\n        else {\n            encoding = options.encoding;\n            opts = options;\n            delete opts.encoding;\n        }\n        const { headers = {}, signal, overrides = {} } = opts;\n        const res = await this.fetch(this.url, {\n            headers,\n            method: 'GET',\n            redirect: 'follow',\n            mode: 'cors',\n            signal,\n            ...this.baseOverrides,\n            ...overrides,\n        });\n        if (res.status !== 200) {\n            throw new Error(`HTTP ${res.status} fetching ${this.url}`);\n        }\n        if (encoding === 'utf8') {\n            return res.text();\n        }\n        else if (encoding) {\n            throw new Error(`unsupported encoding: ${encoding}`);\n        }\n        else {\n            return this.getBufferFromResponse(res);\n        }\n    }\n    async stat() {\n        if (!this._stat) {\n            const buf = Buffer.allocUnsafe(10);\n            await this.read(buf, 0, 10, 0);\n            if (!this._stat) {\n                throw new Error(`unable to determine size of file at ${this.url}`);\n            }\n        }\n        return this._stat;\n    }\n    async close() {\n        return;\n    }\n}\n//# sourceMappingURL=remoteFile.js.map","import { Buffer } from 'buffer';\n// Using this you can \"await\" the file like a normal promise\n// https://blog.shovonhasan.com/using-promises-with-filereader/\nfunction readBlobAsArrayBuffer(blob) {\n    const fileReader = new FileReader();\n    return new Promise((resolve, reject) => {\n        fileReader.onerror = () => {\n            fileReader.abort();\n            reject(new Error('problem reading blob'));\n        };\n        fileReader.onabort = () => {\n            reject(new Error('blob reading was aborted'));\n        };\n        fileReader.onload = () => {\n            if (fileReader.result && typeof fileReader.result !== 'string') {\n                resolve(fileReader.result);\n            }\n            else {\n                reject(new Error('unknown error reading blob'));\n            }\n        };\n        fileReader.readAsArrayBuffer(blob);\n    });\n}\nfunction readBlobAsText(blob) {\n    const fileReader = new FileReader();\n    return new Promise((resolve, reject) => {\n        fileReader.onerror = () => {\n            fileReader.abort();\n            reject(new Error('problem reading blob'));\n        };\n        fileReader.onabort = () => {\n            reject(new Error('blob reading was aborted'));\n        };\n        fileReader.onload = () => {\n            if (fileReader.result && typeof fileReader.result === 'string') {\n                resolve(fileReader.result);\n            }\n            else {\n                reject(new Error('unknown error reading blob'));\n            }\n        };\n        fileReader.readAsText(blob);\n    });\n}\n/**\n * Blob of binary data fetched from a local file (with FileReader).\n *\n * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in\n * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.\n */\nexport default class BlobFile {\n    constructor(blob) {\n        this.blob = blob;\n        this.size = blob.size;\n    }\n    async read(buffer, offset = 0, length, position = 0) {\n        // short-circuit a read of 0 bytes here, because browsers actually sometimes\n        // crash if you try to read 0 bytes from a local file!\n        if (!length) {\n            return { bytesRead: 0, buffer };\n        }\n        const start = position;\n        const end = start + length;\n        const result = await readBlobAsArrayBuffer(this.blob.slice(start, end));\n        const resultBuffer = Buffer.from(result);\n        const bytesCopied = resultBuffer.copy(buffer, offset);\n        return { bytesRead: bytesCopied, buffer: resultBuffer };\n    }\n    async readFile(options) {\n        const encoding = typeof options === 'string' ? options : options === null || options === void 0 ? void 0 : options.encoding;\n        if (encoding === 'utf8') {\n            return readBlobAsText(this.blob);\n        }\n        if (encoding) {\n            throw new Error(`unsupported encoding: ${encoding}`);\n        }\n        const result = await readBlobAsArrayBuffer(this.blob);\n        return Buffer.from(result);\n    }\n    async stat() {\n        return { size: this.size };\n    }\n    async close() {\n        return;\n    }\n}\n//# sourceMappingURL=blobFile.js.map","import LocalFile from './localFile';\nimport RemoteFile from './remoteFile';\nexport * from './filehandle';\nfunction fromUrl(source, opts = {}) {\n    return new RemoteFile(source, opts);\n}\nfunction open(maybeUrl, maybePath, maybeFilehandle, opts = {}) {\n    if (maybeFilehandle !== undefined) {\n        return maybeFilehandle;\n    }\n    if (maybeUrl !== undefined) {\n        return fromUrl(maybeUrl, opts);\n    }\n    if (maybePath !== undefined) {\n        return new LocalFile(maybePath, opts);\n    }\n    throw new Error('no url, path, or filehandle provided, cannot open');\n}\nexport { open, fromUrl };\nexport { default as BlobFile } from './blobFile';\nexport { default as RemoteFile } from './remoteFile';\nexport { default as LocalFile } from './localFile';\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSequenceAdapter = isSequenceAdapter;\nexports.isRegionsAdapter = isRegionsAdapter;\nexports.isFeatureAdapter = isFeatureAdapter;\nexports.isRefNameAliasAdapter = isRefNameAliasAdapter;\nexports.isTextSearchAdapter = isTextSearchAdapter;\nfunction isSequenceAdapter(t) {\n    return 'getRegions' in t && 'getFeatures' in t;\n}\nfunction isRegionsAdapter(t) {\n    return 'getRegions' in t;\n}\nfunction isFeatureAdapter(t) {\n    return 'getFeatures' in t;\n}\nfunction isRefNameAliasAdapter(t) {\n    return 'getRefNameAliases' in t;\n}\nfunction isTextSearchAdapter(t) {\n    return 'searchIndex' in t;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = idMaker;\nconst _1 = require(\"./\");\nfunction idMaker(args, id = '', len = 5000) {\n    const stack = [args];\n    while (stack.length) {\n        const obj = stack.pop();\n        for (const [key, val] of Object.entries(obj)) {\n            if (id.length > len) {\n                return (0, _1.hashCode)(id);\n            }\n            else {\n                if (typeof val === 'object' && val !== null) {\n                    stack.push(val);\n                }\n                else {\n                    id += `${key}-${val}`;\n                }\n            }\n        }\n    }\n    return (0, _1.hashCode)(id);\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseAdapter = void 0;\nconst mobx_state_tree_1 = require(\"mobx-state-tree\");\nconst configuration_1 = require(\"../../configuration\");\nconst idMaker_1 = __importDefault(require(\"../../util/idMaker\"));\nconst EmptyConfig = (0, configuration_1.ConfigurationSchema)('empty', {});\nclass BaseAdapter {\n    constructor(config = EmptyConfig.create(), getSubAdapter, pluginManager) {\n        this.config = config;\n        this.getSubAdapter = getSubAdapter;\n        this.pluginManager = pluginManager;\n        if (typeof jest === 'undefined') {\n            const data = (0, mobx_state_tree_1.isStateTreeNode)(config) ? (0, mobx_state_tree_1.getSnapshot)(config) : config;\n            this.id = `${(0, idMaker_1.default)(data)}`;\n        }\n        else {\n            this.id = 'test';\n        }\n    }\n    getConf(arg) {\n        return (0, configuration_1.readConfObject)(this.config, arg);\n    }\n}\nexports.BaseAdapter = BaseAdapter;\nBaseAdapter.capabilities = [];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservableCreate = ObservableCreate;\nconst rxjs_1 = require(\"rxjs\");\nfunction ObservableCreate(func, _stopToken) {\n    return new rxjs_1.Observable((observer) => {\n        try {\n            const ret = func(observer);\n            if (ret === null || ret === void 0 ? void 0 : ret.catch) {\n                ret.catch((error) => {\n                    observer.error(error);\n                });\n            }\n        }\n        catch (error) {\n            observer.error(error);\n        }\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.calcStdFromSums = calcStdFromSums;\nexports.rectifyStats = rectifyStats;\nexports.scoresToStats = scoresToStats;\nexports.blankStats = blankStats;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nfunction calcStdFromSums(sum, sumSquares, n, population = false) {\n    if (n === 0) {\n        return 0;\n    }\n    let variance;\n    if (population) {\n        variance = sumSquares / n - (sum * sum) / (n * n);\n    }\n    else {\n        variance = sumSquares - (sum * sum) / n;\n        if (n > 1) {\n            variance /= n - 1;\n        }\n    }\n    return variance < 0 ? 0 : Math.sqrt(variance);\n}\nfunction rectifyStats(s) {\n    return {\n        ...s,\n        scoreMean: (s.scoreSum || 0) / (s.featureCount || s.basesCovered || 1),\n        scoreStdDev: calcStdFromSums(s.scoreSum, s.scoreSumSquares, s.featureCount || s.basesCovered),\n        featureDensity: (s.featureCount || 1) / s.basesCovered,\n    };\n}\nasync function scoresToStats(region, feats) {\n    const { start, end } = region;\n    const seed = {\n        scoreMin: Number.MAX_VALUE,\n        scoreMax: Number.MIN_VALUE,\n        scoreSum: 0,\n        scoreSumSquares: 0,\n        featureCount: 0,\n    };\n    let found = false;\n    const { scoreMin, scoreMax, scoreSum, scoreSumSquares, featureCount } = await (0, rxjs_1.firstValueFrom)(feats.pipe((0, operators_1.reduce)((acc, f) => {\n        const s = f.get('score');\n        const summary = f.get('summary');\n        const { scoreMax, scoreMin } = acc;\n        acc.scoreMax = Math.max(scoreMax, summary ? f.get('maxScore') : s);\n        acc.scoreMin = Math.min(scoreMin, summary ? f.get('minScore') : s);\n        acc.scoreSum += s;\n        acc.scoreSumSquares += s * s;\n        acc.featureCount += 1;\n        found = true;\n        return acc;\n    }, seed)));\n    return found\n        ? rectifyStats({\n            scoreMax,\n            scoreMin,\n            scoreSum,\n            scoreSumSquares,\n            featureCount,\n            basesCovered: end - start + 1,\n        })\n        : blankStats();\n}\nfunction blankStats() {\n    return {\n        scoreMin: 0,\n        scoreMax: 0,\n        scoreMean: 0,\n        scoreStdDev: 0,\n        scoreSum: 0,\n        scoreSumSquares: 0,\n        featureCount: 0,\n        featureDensity: 0,\n        basesCovered: 0,\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseFeatureDataAdapter = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst BaseAdapter_1 = require(\"./BaseAdapter\");\nconst util_1 = require(\"../../util\");\nconst rxjs_2 = require(\"../../util/rxjs\");\nconst stats_1 = require(\"../../util/stats\");\nconst stopToken_1 = require(\"../../util/stopToken\");\nclass BaseFeatureDataAdapter extends BaseAdapter_1.BaseAdapter {\n    async getHeader(_opts) {\n        return null;\n    }\n    async getMetadata(_opts) {\n        return null;\n    }\n    getFeaturesInRegion(region, opts = {}) {\n        return (0, rxjs_2.ObservableCreate)(async (observer) => {\n            const hasData = await this.hasDataForRefName(region.refName, opts);\n            (0, stopToken_1.checkStopToken)(opts.stopToken);\n            if (!hasData) {\n                observer.complete();\n            }\n            else {\n                this.getFeatures(region, opts).subscribe(observer);\n            }\n        });\n    }\n    getFeaturesInMultipleRegions(regions, opts = {}) {\n        return (0, rxjs_1.merge)(...regions.map(region => this.getFeaturesInRegion(region, opts)));\n    }\n    async hasDataForRefName(refName, opts = {}) {\n        const refNames = await this.getRefNames(opts);\n        return refNames.includes(refName);\n    }\n    async getRegionQuantitativeStats(region, opts) {\n        const feats = this.getFeatures(region, opts);\n        return (0, stats_1.scoresToStats)(region, feats);\n    }\n    async getMultiRegionQuantitativeStats(regions = [], opts) {\n        if (!regions.length) {\n            return (0, stats_1.blankStats)();\n        }\n        const feats = await Promise.all(regions.map(region => this.getRegionQuantitativeStats(region, opts)));\n        const scoreMax = (0, util_1.max)(feats.map(a => a.scoreMax));\n        const scoreMin = (0, util_1.min)(feats.map(a => a.scoreMin));\n        const scoreSum = (0, util_1.sum)(feats.map(a => a.scoreSum));\n        const scoreSumSquares = (0, util_1.sum)(feats.map(a => a.scoreSumSquares));\n        const featureCount = (0, util_1.sum)(feats.map(a => a.featureCount));\n        const basesCovered = (0, util_1.sum)(feats.map(a => a.basesCovered));\n        return (0, stats_1.rectifyStats)({\n            scoreMin,\n            scoreMax,\n            featureCount,\n            basesCovered,\n            scoreSumSquares,\n            scoreSum,\n        });\n    }\n    getRegionFeatureDensityStats(region, opts) {\n        let lastTime = +Date.now();\n        const statsFromInterval = async (length, expansionTime) => {\n            const { start, end } = region;\n            const sampleCenter = start * 0.75 + end * 0.25;\n            const features = await (0, rxjs_1.firstValueFrom)(this.getFeatures({\n                ...region,\n                start: Math.max(0, Math.round(sampleCenter - length / 2)),\n                end: Math.min(Math.round(sampleCenter + length / 2), end),\n            }, opts).pipe((0, operators_1.toArray)()));\n            return maybeRecordStats(length, { featureDensity: features.length / length }, features.length, expansionTime);\n        };\n        const maybeRecordStats = async (interval, stats, statsSampleFeatures, expansionTime) => {\n            const refLen = region.end - region.start;\n            if (statsSampleFeatures >= 70 || interval * 2 > refLen) {\n                return stats;\n            }\n            else if (expansionTime <= 5000) {\n                const currTime = +Date.now();\n                expansionTime += currTime - lastTime;\n                lastTime = currTime;\n                return statsFromInterval(interval * 2, expansionTime);\n            }\n            else {\n                console.warn(\"Stats estimation reached timeout, or didn't get enough features\");\n                return { featureDensity: Number.POSITIVE_INFINITY };\n            }\n        };\n        return statsFromInterval(1000, 0);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        if (!regions.length) {\n            throw new Error('No regions supplied');\n        }\n        return this.getRegionFeatureDensityStats(regions[0], opts);\n    }\n    async getSources(regions) {\n        const features = await (0, rxjs_1.firstValueFrom)(this.getFeaturesInMultipleRegions(regions).pipe((0, operators_1.toArray)()));\n        const sources = new Set();\n        for (const f of features) {\n            sources.add(f.get('source'));\n        }\n        return [...sources].map(source => ({\n            name: source,\n        }));\n    }\n}\nexports.BaseFeatureDataAdapter = BaseFeatureDataAdapter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseSequenceAdapter = void 0;\nconst BaseFeatureDataAdapter_1 = require(\"./BaseFeatureDataAdapter\");\nclass BaseSequenceAdapter extends BaseFeatureDataAdapter_1.BaseFeatureDataAdapter {\n    async getMultiRegionFeatureDensityStats() {\n        return { featureDensity: 0 };\n    }\n}\nexports.BaseSequenceAdapter = BaseSequenceAdapter;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseSequenceAdapter = exports.BaseFeatureDataAdapter = exports.BaseAdapter = void 0;\n__exportStar(require(\"./util\"), exports);\n__exportStar(require(\"./types\"), exports);\nvar BaseAdapter_1 = require(\"./BaseAdapter\");\nObject.defineProperty(exports, \"BaseAdapter\", { enumerable: true, get: function () { return BaseAdapter_1.BaseAdapter; } });\nvar BaseFeatureDataAdapter_1 = require(\"./BaseFeatureDataAdapter\");\nObject.defineProperty(exports, \"BaseFeatureDataAdapter\", { enumerable: true, get: function () { return BaseFeatureDataAdapter_1.BaseFeatureDataAdapter; } });\nvar BaseSequenceAdapter_1 = require(\"./BaseSequenceAdapter\");\nObject.defineProperty(exports, \"BaseSequenceAdapter\", { enumerable: true, get: function () { return BaseSequenceAdapter_1.BaseSequenceAdapter; } });\n","//@ts-nocheck\nexport function parseCacheControl(field) {\n    if (typeof field !== 'string') {\n        return {};\n    }\n    const parsed = {};\n    const invalid = field\n        .toLowerCase()\n        .replace(/(?:^|(?:\\s*,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (match, fieldName, three, four) => {\n        const value = three || four;\n        parsed[fieldName] = value ? value.toLowerCase() : true;\n        return '';\n    });\n    if (invalid) {\n        return {};\n    }\n    // parse any things that seem to be numbers\n    Object.keys(parsed).forEach(key => {\n        if (/^[\\d]+$/.test(parsed[key])) {\n            try {\n                const num = parseInt(parsed[key], 10);\n                if (!Number.isNaN(num)) {\n                    parsed[key] = num;\n                }\n            }\n            catch (e) {\n                /* ignore */\n            }\n        }\n    });\n    return parsed;\n}\nexport class CacheSemantics {\n    constructor({ minimumTTL }) {\n        this.minimumTTL = minimumTTL;\n    }\n    calculateChunkExpirationDate(chunkResponse) {\n        const { headers = {}, requestDate, responseDate } = chunkResponse;\n        let baselineDate = responseDate || requestDate;\n        if (!baselineDate) {\n            if (!headers.date) {\n                return undefined;\n            }\n            baselineDate = new Date(headers.date);\n        }\n        const basePlus = ttl => new Date(baselineDate.getTime() + ttl);\n        // results that are not really cacheable expire after the minimum time to live\n        if (/\\bno-cache\\b/.test(headers.pragma)) {\n            return basePlus(this.minimumTTL);\n        }\n        const cacheControl = parseCacheControl(headers['cache-control']);\n        if (cacheControl['no-cache'] ||\n            cacheControl['no-store'] ||\n            cacheControl['must-revalidate']) {\n            return basePlus(this.minimumTTL);\n        }\n        if (cacheControl['max-age'] !== undefined) {\n            const ttl = cacheControl['max-age'] * 1000; // max-age is in seconds\n            return basePlus(Math.max(ttl, this.minimumTTL));\n        }\n        else if (this._coerceToDate(headers.expires)) {\n            return this._coerceToDate(headers.expires);\n        }\n        else if (this._coerceToDate(headers['last-modified'])) {\n            const lastModified = this._coerceToDate(headers['last-modified']);\n            const ttl = (baselineDate.getTime() - lastModified.getTime()) / 10;\n            return basePlus(ttl);\n        }\n        // otherwise, we just cache forever\n        return undefined;\n    }\n    _coerceToDate(thing) {\n        if (thing) {\n            if (thing instanceof Date) {\n                return thing;\n            }\n            if (typeof thing === 'string' || typeof thing === 'number') {\n                return new Date(thing);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * check whether a cached chunk response is still valid and can be used\n     * @param {object} chunkResponse\n     * @returns {boolean}\n     */\n    cachedChunkIsValid(chunkResponse) {\n        const expiration = this.calculateChunkExpirationDate(chunkResponse);\n        return !expiration || new Date() <= expiration;\n    }\n    /**\n     * check whether the response for this chunk fetch can be cached\n     * @param {object} chunkResponse\n     * @returns {boolean}\n     */\n    chunkIsCacheable() {\n        // right now, we are caching everything, we just give it a very short\n        // time to live if it's not supposed to be cached\n        return true;\n    }\n}\n//# sourceMappingURL=cacheSemantics.js.map","//@ts-nocheck\n/**\n * takes fetch requests and aggregates them at a certain time frequency\n */\nexport default class AggregatingFetcher {\n    /**\n     *\n     * @param {object} params\n     * @param {number} [params.frequency] number of milliseconds to wait for requests to aggregate\n     */\n    constructor({ frequency = 100, fetch, maxExtraSize = 32000, maxFetchSize = 1000000, }) {\n        this.requestQueues = {}; // url => array of requests\n        this.fetchCallback = fetch;\n        this.frequency = frequency;\n        this.maxExtraSize = maxExtraSize;\n        this.maxFetchSize = maxFetchSize;\n    }\n    _canAggregate(requestGroup, request) {\n        return (\n        // the fetches overlap, or come close\n        request.start <= requestGroup.end + this.maxExtraSize &&\n            // aggregating would not result in a fetch that is too big\n            request.end - request.start + requestGroup.end - requestGroup.start <\n                this.maxFetchSize);\n    }\n    // returns a promise that only resolves\n    // when all of the signals in the given array\n    // have fired their abort signal\n    _allSignalsFired(signals) {\n        return new Promise(resolve => {\n            let signalsLeft = signals.filter(s => !s.aborted).length;\n            signals.forEach(signal => {\n                signal.addEventListener('abort', () => {\n                    signalsLeft -= 1;\n                    // console.log('aggregatingfetcher received an abort')\n                    if (!signalsLeft) {\n                        // console.log('aggregatingfetcher aborting aggegated request')\n                        resolve();\n                    }\n                });\n            });\n        }).catch(e => {\n            console.error(e);\n        });\n    }\n    // dispatch a request group as a single request\n    // and then slice the result back up to satisfy\n    // the individual requests\n    _dispatch({ url, start, end, requests }) {\n        // if any of the requests have an AbortSignal `signal` in their requestOptions,\n        // make our aggregating abortcontroller track it, aborting the request if\n        // all of the abort signals that are aggregated here have fired\n        const abortWholeRequest = new AbortController();\n        const signals = [];\n        requests.forEach(({ requestOptions }) => {\n            if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {\n                signals.push(requestOptions.signal);\n            }\n        });\n        if (signals.length === requests.length) {\n            // may need review\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._allSignalsFired(signals).then(() => abortWholeRequest.abort());\n        }\n        this.fetchCallback(url, start, end - 1, {\n            signal: abortWholeRequest.signal,\n        }).then(response => {\n            const data = response.buffer;\n            requests.forEach(({ start: reqStart, end: reqEnd, resolve }) => {\n                // remember Buffer.slice does not copy, it creates\n                // an offset child buffer pointing to the same data\n                resolve({\n                    headers: response.headers,\n                    buffer: data.slice(reqStart - start, reqEnd - start),\n                });\n            });\n        }, err => {\n            requests.forEach(({ reject }) => reject(err));\n        });\n    }\n    _aggregateAndDispatch() {\n        Object.entries(this.requestQueues).forEach(([url, requests]) => {\n            if (!(requests === null || requests === void 0 ? void 0 : requests.length)) {\n                return;\n            }\n            // console.log(url, requests)\n            // we are now going to aggregate the requests in this url's queue\n            // into groups of requests that can be dispatched as one\n            const requestsToDispatch = [];\n            // look to see if any of the requests are aborted, and if they are, just\n            // reject them now and forget about them\n            requests.forEach(request => {\n                var _a;\n                const { requestOptions, reject } = request;\n                if ((_a = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                    reject(Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' }));\n                }\n                else {\n                    requestsToDispatch.push(request);\n                }\n            });\n            requestsToDispatch.sort((a, b) => a.start - b.start);\n            requests.length = 0;\n            if (!requestsToDispatch.length) {\n                return;\n            }\n            let currentRequestGroup;\n            for (const next of requestsToDispatch) {\n                if (currentRequestGroup &&\n                    this._canAggregate(currentRequestGroup, next)) {\n                    // aggregate it into the current group\n                    currentRequestGroup.requests.push(next);\n                    currentRequestGroup.end = next.end;\n                }\n                else {\n                    // out of range, dispatch the current request group\n                    if (currentRequestGroup) {\n                        this._dispatch(currentRequestGroup);\n                    }\n                    // and start on a new one\n                    currentRequestGroup = {\n                        requests: [next],\n                        url,\n                        start: next.start,\n                        end: next.end,\n                    };\n                }\n            }\n            if (currentRequestGroup) {\n                this._dispatch(currentRequestGroup);\n            }\n        });\n    }\n    _enQueue(url, request) {\n        if (!this.requestQueues[url]) {\n            this.requestQueues[url] = [];\n        }\n        this.requestQueues[url].push(request);\n    }\n    /**\n     *\n     * @param {string} url\n     * @param {number} start 0-based half-open\n     * @param {number} end 0-based half-open\n     * @param {object} [requestOptions] options passed to the underlying fetch call\n     */\n    fetch(url, start, end, requestOptions = {}) {\n        return new Promise((resolve, reject) => {\n            this._enQueue(url, { start, end, resolve, reject, requestOptions });\n            if (!this.timeout) {\n                this.timeout = setTimeout(() => {\n                    this.timeout = undefined;\n                    this._aggregateAndDispatch();\n                }, this.frequency || 1);\n            }\n        });\n    }\n}\n//# sourceMappingURL=aggregatingFetcher.js.map","//@ts-nocheck\nimport { Buffer } from 'buffer';\nexport default async function crossFetchBinaryRange(url, start, end, options = {}) {\n    const requestDate = new Date();\n    const fetchOptions = Object.assign({\n        method: 'GET',\n        headers: { range: `bytes=${start}-${end}` },\n    }, options);\n    const res = await fetch(url, fetchOptions);\n    const responseDate = new Date();\n    if (res.status !== 206 && res.status !== 200) {\n        throw new Error(`HTTP ${res.status} when fetching ${url} bytes ${start}-${end}`);\n    }\n    if (res.status === 200) {\n        // TODO: check that the response satisfies the byte range,\n        // and is not too big (check maximum size),\n        // because we actually ended up getting served the whole file\n        throw new Error(`HTTP ${res.status} when fetching ${url} bytes ${start}-${end}`);\n    }\n    const buffer = await res\n        .arrayBuffer()\n        .then(arrayBuffer => Buffer.from(arrayBuffer));\n    // return the response headers, and the data buffer\n    return {\n        headers: res.headers.map,\n        requestDate,\n        responseDate,\n        buffer,\n    };\n}\n//# sourceMappingURL=crossFetchBinaryRange.js.map","//@ts-nocheck\nimport { Buffer } from 'buffer';\nimport LRU from 'quick-lru';\nimport { CacheSemantics } from './cacheSemantics';\nimport AggregatingFetcher from './aggregatingFetcher';\nimport crossFetchBinaryRange from './crossFetchBinaryRange';\n/**\n * check if the given exception was caused by an operation being intentionally aborted\n * @param {Error} exception\n * @returns {boolean}\n */\nfunction isAbortException(exception) {\n    return (\n    // DOMException\n    exception.name === 'AbortError' ||\n        // standard-ish non-DOM abort exception\n        // @ts-ignore\n        exception.code === 'ERR_ABORTED' ||\n        // message contains aborted for bubbling through RPC\n        // things we have seen that we want to catch here\n        // Error: aborted\n        // AbortError: aborted\n        // AbortError: The user aborted a request.\n        !!exception.message.match(/\\b(aborted|AbortError)\\b/i));\n}\n// TODO: fire events when a remote file is detected as having been changed\n/**\n * smart cache that fetches chunks of remote files.\n * caches chunks in an LRU cache, and aggregates upstream fetches\n */\nexport default class HttpRangeFetcher {\n    /**\n     * @param {object} args the arguments object\n     * @param {number} [args.fetch] callback with signature `(key, start, end) => Promise({ headers, buffer })`\n     * @param {number} [args.size] size in bytes of cache to keep\n     * @param {number} [args.chunkSize] size in bytes of cached chunks\n     * @param {number} [args.aggregationTime] time in ms over which to pool requests before dispatching them\n     * @param {number} [args.minimumTTL] time in ms a non-cacheable response will be cached\n     * @param {number} [args.maxFetchSize] maximum size of an aggregated request\n     * @param {number} [args.maxExtraFetch] max number of additional bytes to fetch when aggregating requests\n     * that don't actually overlap\n     */\n    constructor({ fetch = crossFetchBinaryRange, size = 10000000, chunkSize = 32768, aggregationTime = 100, minimumTTL = 1000, maxFetchSize = chunkSize * 4, maxExtraFetch = chunkSize, }) {\n        this.aggregator = new AggregatingFetcher({\n            fetch,\n            frequency: aggregationTime,\n            maxFetchSize,\n            maxExtraSize: maxExtraFetch,\n        });\n        this.chunkSize = chunkSize;\n        this.chunkCache = new LRU({ maxSize: Math.floor(size / chunkSize) || 1 });\n        this.cacheSemantics = new CacheSemantics({ minimumTTL });\n        this.stats = new LRU({ maxSize: 20 });\n    }\n    /**\n     * Fetch a range of a remote resource.\n     * @param {string} key the resource's unique identifier, this would usually be a URL.\n     * This is passed along to the fetch callback.\n     * @param {number} [position] offset in the file at which to start fetching\n     * @param {number} [length] number of bytes to fetch, defaults to the remainder of the file\n     * @param {object} [options] request options\n     * @param {AbortSignal} [options.signal] AbortSignal object that can be used to abort the fetch\n     */\n    async getRange(key, position = 0, requestedLength, options = {}) {\n        let length = requestedLength;\n        if (length === undefined) {\n            const stat = await this.stat(key);\n            if (stat.size === undefined) {\n                throw new Error(`length not specified, and could not determine size of the remote file`);\n            }\n            length = stat.size - position;\n        }\n        // calculate the list of chunks involved in this fetch\n        const firstChunk = Math.floor(position / this.chunkSize);\n        const lastChunk = Math.floor((position + length - 1) / this.chunkSize);\n        // fetch them all as necessary\n        const fetches = new Array(lastChunk - firstChunk + 1);\n        for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n            fetches[chunk - firstChunk] = this._getChunk(key, chunk, options).then(response => response && {\n                headers: response.headers,\n                buffer: response.buffer,\n                chunkNumber: chunk,\n            });\n        }\n        // return a \"composite buffer\" that lets the array of chunks be accessed like a flat buffer\n        let chunkResponses = await Promise.all(fetches);\n        chunkResponses = chunkResponses.filter(r => !!r); // filter out any undefined (out of range) responses\n        if (!chunkResponses.length) {\n            return { headers: {}, buffer: Buffer.allocUnsafe(0) };\n        }\n        const chunksOffset = position - chunkResponses[0].chunkNumber * this.chunkSize;\n        return {\n            headers: this._makeHeaders(chunkResponses[0].headers, position, position + length - 1),\n            buffer: this._makeBuffer(chunkResponses, chunksOffset, length),\n        };\n    }\n    _makeBuffer(chunkResponses, chunksOffset, length) {\n        if (chunkResponses.length === 1) {\n            return chunkResponses[0].buffer.slice(chunksOffset, chunksOffset + length);\n        }\n        else if (chunkResponses.length === 0) {\n            return Buffer.allocUnsafe(0);\n        }\n        // 2 or more buffers\n        const buffers = chunkResponses.map(r => r.buffer);\n        const first = buffers.shift().slice(chunksOffset);\n        let last = buffers.pop();\n        let trimEnd = first.length +\n            buffers.reduce((sum, buf) => sum + buf.length, 0) +\n            last.length -\n            length;\n        if (trimEnd < 0) {\n            trimEnd = 0;\n        }\n        last = last.slice(0, last.length - trimEnd);\n        return Buffer.concat([first, ...buffers, last]);\n    }\n    /**\n     * Fetches the first few bytes of the remote file (if necessary) and uses\n     * the returned headers to populate a `fs`-like stat object.\n     *\n     * Currently, this attempts to set `size`, `mtime`, and `mtimeMs`, if\n     * the information is available from HTTP headers.\n     *\n     * @param {string} key\n     * @returns {Promise} for a stats object\n     */\n    async stat(key) {\n        let stat = this.stats.get(key);\n        if (!stat) {\n            const chunk = await this._getChunk(key, 0);\n            this._recordStatsIfNecessary(key, chunk);\n            stat = this.stats.get(key);\n            if (!stat) {\n                throw new Error(`failed to retrieve file size for ${key}`);\n            }\n        }\n        return stat;\n    }\n    _headersToStats(chunkResponse) {\n        const { headers } = chunkResponse;\n        const stat = {};\n        if (headers['content-range']) {\n            const match = headers['content-range'].match(/\\d+-\\d+\\/(\\d+)/);\n            if (match) {\n                stat.size = parseInt(match[1], 10);\n                if (Number.isNaN(stat.size)) {\n                    delete stat.size;\n                }\n            }\n        }\n        if (headers['last-modified']) {\n            stat.mtime = new Date(headers['last-modified']);\n            if (stat.mtime.toString() === 'Invalid Date') {\n                delete stat.mtime;\n            }\n            if (stat.mtime) {\n                stat.mtimeMs = stat.mtime.getTime();\n            }\n        }\n        return stat;\n    }\n    _makeHeaders(originalHeaders, newStart, newEnd) {\n        const newHeaders = Object.assign({}, originalHeaders || {});\n        newHeaders['content-length'] = newEnd - newStart;\n        const oldContentRange = newHeaders['content-range'] || '';\n        const match = oldContentRange.match(/\\d+-\\d+\\/(\\d+)/);\n        if (match) {\n            newHeaders['content-range'] = `${newStart}-${newEnd - 1}/${match[1]}`;\n            newHeaders['x-resource-length'] = match[1];\n        }\n        return newHeaders;\n    }\n    async _getChunk(key, chunkNumber, requestOptions) {\n        const chunkKey = `${key}/${chunkNumber}`;\n        const cachedPromise = this.chunkCache.get(chunkKey);\n        if (cachedPromise) {\n            let chunk;\n            let chunkAborted;\n            try {\n                chunk = await cachedPromise;\n            }\n            catch (err) {\n                if (isAbortException(err)) {\n                    // fetch was aborted\n                    chunkAborted = true;\n                }\n                else {\n                    throw err;\n                }\n            }\n            // when the cached chunk is resolved, validate it before returning it.\n            // if invalid or aborted, delete it from the cache and redispatch the request\n            if (chunkAborted || !this.cacheSemantics.cachedChunkIsValid(chunk)) {\n                this._uncacheIfSame(chunkKey, cachedPromise);\n                return this._getChunk(key, chunkNumber, requestOptions);\n            }\n            // gather the stats for the file from the headers\n            this._recordStatsIfNecessary(key, chunk);\n            return chunk;\n        }\n        const fetchStart = chunkNumber * this.chunkSize;\n        let fetchEnd = fetchStart + this.chunkSize;\n        // clamp the end of the fetch to the size if we have a cached size for the file\n        const stat = this.stats.get(key);\n        if (stat === null || stat === void 0 ? void 0 : stat.size) {\n            if (fetchStart >= stat.size) {\n                return undefined;\n            }\n            if (fetchEnd >= stat.size) {\n                fetchEnd = stat.size;\n            }\n        }\n        let alreadyRejected = false;\n        const freshPromise = this.aggregator\n            .fetch(key, fetchStart, fetchEnd, requestOptions)\n            .catch(err => {\n            // if the request fails, remove its promise\n            // from the cache and keep the error\n            alreadyRejected = true;\n            this._uncacheIfSame(chunkKey, freshPromise);\n            throw err;\n        });\n        if (!alreadyRejected) {\n            this.chunkCache.set(chunkKey, freshPromise);\n        }\n        const freshChunk = await freshPromise;\n        // gather the stats for the file from the headers\n        this._recordStatsIfNecessary(key, freshChunk);\n        // remove the promise from the cache\n        // if it turns out not to be cacheable. this is\n        // done after the fact because we want multiple requests\n        // for the same chunk to reuse the same cached promise\n        if (!this.cacheSemantics.chunkIsCacheable(freshChunk)) {\n            this._uncacheIfSame(chunkKey, freshPromise);\n        }\n        return freshChunk;\n    }\n    // if the stats for a resource haven't been recorded yet, record them\n    _recordStatsIfNecessary(key, chunk) {\n        if (!this.stats.has(key)) {\n            this.stats.set(key, this._headersToStats(chunk));\n        }\n    }\n    // delete a promise from the cache if it is still in there.\n    // need to check if it is still the same because it might\n    // have been overwritten sometime while the promise was in flight\n    _uncacheIfSame(key, cachedPromise) {\n        if (this.chunkCache.get(key) === cachedPromise) {\n            this.chunkCache.delete(key);\n        }\n    }\n    /**\n     * Throw away all cached data, resetting the cache.\n     */\n    reset() {\n        this.stats.clear();\n        this.chunkCache.clear();\n    }\n}\n//# sourceMappingURL=httpRangeFetcher.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteFileWithRangeCache = void 0;\nexports.clearCache = clearCache;\nconst buffer_1 = require(\"buffer\");\nconst http_range_fetcher_1 = require(\"@gmod/http-range-fetcher\");\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst fetchers = {};\nfunction binaryRangeFetch(url, start, end, options = {}) {\n    const fetcher = fetchers[url];\n    if (!fetcher) {\n        throw new Error(`fetch not registered for ${url}`);\n    }\n    return fetcher(url, start, end, options);\n}\nconst globalRangeCache = new http_range_fetcher_1.HttpRangeFetcher({\n    fetch: binaryRangeFetch,\n    size: 500 * 1024 ** 2,\n    chunkSize: 128 * 1024,\n    maxFetchSize: 100 * 1024 ** 2,\n    minimumTTL: 24 * 60 * 60 * 1000,\n});\nfunction clearCache() {\n    globalRangeCache.reset();\n}\nclass RemoteFileWithRangeCache extends generic_filehandle_1.RemoteFile {\n    async fetch(url, init) {\n        const str = String(url);\n        if (!fetchers[str]) {\n            fetchers[str] = this.fetchBinaryRange.bind(this);\n        }\n        const range = new Headers(init === null || init === void 0 ? void 0 : init.headers).get('range');\n        if (range) {\n            const rangeParse = /bytes=(\\d+)-(\\d+)/.exec(range);\n            if (rangeParse) {\n                const [, start, end] = rangeParse;\n                const s = Number.parseInt(start, 10);\n                const e = Number.parseInt(end, 10);\n                const len = e - s;\n                const { buffer, headers } = (await globalRangeCache.getRange(url, s, len + 1));\n                return new Response(buffer, { status: 206, headers });\n            }\n        }\n        return super.fetch(url, init);\n    }\n    async fetchBinaryRange(url, start, end, options = {}) {\n        const requestDate = new Date();\n        const res = await super.fetch(url, {\n            ...options,\n            headers: {\n                ...options.headers,\n                range: `bytes=${start}-${end}`,\n            },\n        });\n        const responseDate = new Date();\n        if (!res.ok) {\n            const errorMessage = `HTTP ${res.status} fetching ${url} bytes ${start}-${end}`;\n            const hint = ' (should be 206 for range requests)';\n            throw new Error(`${errorMessage}${res.status === 200 ? hint : ''}`);\n        }\n        const headers = {};\n        for (const [k, v] of res.headers.entries()) {\n            headers[k] = v;\n        }\n        const arrayBuffer = await res.arrayBuffer();\n        return {\n            headers,\n            requestDate,\n            responseDate,\n            buffer: buffer_1.Buffer.from(arrayBuffer),\n        };\n    }\n}\nexports.RemoteFileWithRangeCache = RemoteFileWithRangeCache;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RemoteFileWithRangeCache = void 0;\nexports.resolveUriLocation = resolveUriLocation;\nexports.openLocation = openLocation;\nexports.getFetcher = getFetcher;\nconst detect_node_1 = __importDefault(require(\"detect-node\"));\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst RemoteFileWithRangeCache_1 = require(\"./RemoteFileWithRangeCache\");\nconst __1 = require(\"../\");\nconst tracks_1 = require(\"../tracks\");\nconst types_1 = require(\"../types\");\nfunction isLocalPathLocation(location) {\n    return 'localPath' in location;\n}\nfunction isBlobLocation(location) {\n    return 'blobId' in location;\n}\nfunction resolveUriLocation(location) {\n    return location.baseUri\n        ? { ...location, uri: new URL(location.uri, location.baseUri).href }\n        : location;\n}\nfunction openLocation(location, pluginManager) {\n    if (isLocalPathLocation(location)) {\n        if (!location.localPath) {\n            throw new Error('No local path provided');\n        }\n        if (detect_node_1.default || __1.isElectron) {\n            return new generic_filehandle_1.LocalFile(location.localPath);\n        }\n        else {\n            throw new Error(\"can't use local files in the browser\");\n        }\n    }\n    if (isBlobLocation(location)) {\n        const blob = (0, tracks_1.getBlob)(location.blobId);\n        if (!blob) {\n            throw new Error(`file (\"${location.name}\") was opened locally from a previous session. To restore it, go to track settings and reopen the file`);\n        }\n        return new generic_filehandle_1.BlobFile(blob);\n    }\n    if ((0, types_1.isUriLocation)(location)) {\n        if (!location.uri) {\n            throw new Error('No URI provided');\n        }\n        const absoluteLocation = resolveUriLocation(location);\n        if (pluginManager) {\n            const internetAccount = getInternetAccount(location, pluginManager);\n            if (internetAccount) {\n                return internetAccount.openLocation(absoluteLocation);\n            }\n        }\n        return new RemoteFileWithRangeCache_1.RemoteFileWithRangeCache(absoluteLocation.uri, {\n            fetch: checkAuthNeededFetch,\n        });\n    }\n    throw new Error('invalid fileLocation');\n}\nfunction getFetcher(location, pluginManager) {\n    if (!(0, types_1.isUriLocation)(location)) {\n        throw new Error(`Not a valid UriLocation: ${JSON.stringify(location)}`);\n    }\n    if (pluginManager) {\n        const internetAccount = getInternetAccount(location, pluginManager);\n        if (internetAccount) {\n            return internetAccount.getFetcher(location);\n        }\n    }\n    return checkAuthNeededFetch;\n}\nfunction getInternetAccount(location, pluginManager) {\n    const { rootModel } = pluginManager;\n    if (rootModel && (0, types_1.isRootModelWithInternetAccounts)(rootModel)) {\n        return rootModel.findAppropriateInternetAccount(location);\n    }\n    if (location.internetAccountPreAuthorization) {\n        if (!location.internetAccountPreAuthorization.authInfo.token) {\n            throw new Error('Failed to obtain token from internet account. Try reloading the page');\n        }\n        return pluginManager\n            .getInternetAccountType(location.internetAccountPreAuthorization.internetAccountType)\n            .stateModel.create({\n            type: location.internetAccountPreAuthorization.internetAccountType,\n            configuration: location.internetAccountPreAuthorization.authInfo.configuration,\n        });\n    }\n    return undefined;\n}\nasync function checkAuthNeededFetch(url, opts) {\n    var _a;\n    const response = await fetch(url, opts);\n    if (response.status === 401 &&\n        ((_a = response.headers.get('WWW-Authenticate')) === null || _a === void 0 ? void 0 : _a.includes('Basic'))) {\n        throw new types_1.AuthNeededError('Accessing HTTPBasic resource without authentication', url.toString());\n    }\n    return response;\n}\nvar RemoteFileWithRangeCache_2 = require(\"./RemoteFileWithRangeCache\");\nObject.defineProperty(exports, \"RemoteFileWithRangeCache\", { enumerable: true, get: function () { return RemoteFileWithRangeCache_2.RemoteFileWithRangeCache; } });\n"],"names":["getMessage","e","RemoteFile","response","resp","Buffer","source","opts","fetch","input","init","buffer","offset","length","position","headers","signal","overrides","res","resData","bytesCopied","contentRange","sizeMatch","options","encoding","buf","readBlobAsArrayBuffer","blob","fileReader","resolve","reject","readBlobAsText","BlobFile","start","end","result","resultBuffer","fromUrl","open","maybeUrl","maybePath","maybeFilehandle","LocalFile","util","isSequenceAdapter","isRegionsAdapter","isFeatureAdapter","isRefNameAliasAdapter","isTextSearchAdapter","t","types","idMaker_1","idMaker","_1","require$$0","args","id","len","stack","obj","key","val","__importDefault","this","mod","BaseAdapter_1","mobx_state_tree_1","configuration_1","require$$1","require$$2","EmptyConfig","BaseAdapter","config","getSubAdapter","pluginManager","data","arg","rxjs","ObservableCreate_1","ObservableCreate","rxjs_1","func","_stopToken","observer","ret","error","stats","calcStdFromSums","rectifyStats","scoresToStats","blankStats","operators_1","sum","sumSquares","n","population","variance","s","region","feats","seed","found","scoreMin","scoreMax","scoreSum","scoreSumSquares","featureCount","acc","f","summary","BaseFeatureDataAdapter_1","util_1","require$$3","rxjs_2","require$$4","stats_1","require$$5","stopToken_1","require$$6","BaseFeatureDataAdapter","_opts","hasData","regions","refName","a","basesCovered","lastTime","statsFromInterval","expansionTime","sampleCenter","features","maybeRecordStats","interval","statsSampleFeatures","refLen","currTime","sources","BaseSequenceAdapter_1","BaseSequenceAdapter","__createBinding","o","m","k","k2","desc","__exportStar","exports","p","parseCacheControl","field","parsed","match","fieldName","three","four","value","num","CacheSemantics","minimumTTL","chunkResponse","requestDate","responseDate","baselineDate","basePlus","ttl","cacheControl","lastModified","thing","expiration","AggregatingFetcher","frequency","maxExtraSize","maxFetchSize","requestGroup","request","signals","signalsLeft","url","requests","abortWholeRequest","requestOptions","reqStart","reqEnd","err","requestsToDispatch","_a","b","currentRequestGroup","next","crossFetchBinaryRange","fetchOptions","arrayBuffer","isAbortException","exception","HttpRangeFetcher","size","chunkSize","aggregationTime","maxExtraFetch","LRU","requestedLength","stat","firstChunk","lastChunk","fetches","chunk","chunkResponses","r","chunksOffset","buffers","first","last","trimEnd","originalHeaders","newStart","newEnd","newHeaders","chunkNumber","chunkKey","cachedPromise","chunkAborted","fetchStart","fetchEnd","alreadyRejected","freshPromise","freshChunk","RemoteFileWithRangeCache_1","clearCache","buffer_1","http_range_fetcher_1","generic_filehandle_1","fetchers","binaryRangeFetch","fetcher","globalRangeCache","RemoteFileWithRangeCache","str","range","rangeParse","errorMessage","hint","v","resolveUriLocation","openLocation","getFetcher","detect_node_1","__1","tracks_1","types_1","isLocalPathLocation","location","isBlobLocation","absoluteLocation","internetAccount","getInternetAccount","checkAuthNeededFetch","rootModel","RemoteFileWithRangeCache_2"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]}