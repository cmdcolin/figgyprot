import{p as _,aD as P,dT as F,bb as O,dU as R,dV as $,dW as E,am as N,an as T,dX as k}from"./index-CGKDrrCR.js";import{g as I}from"./getMaximumModificationAtEachPosition-IYUBfDVk.js";function B({feature:s,bins:e,region:t}){const o=s.get("start"),r=s.get("end"),n=s.get("strand"),f=t.end-t.start;for(let i=o;i<r+1;i++){const c=i-t.start;c>=0&&c<f&&(e[c]===void 0&&(e[c]={depth:0,readsCounted:0,ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},snps:{},mods:{},nonmods:{},delskips:{},noncov:{}}),i!==r&&(e[c].depth++,e[c].readsCounted++,e[c].ref.entryDepth++,e[c].ref[n]++))}}function L(s){return x(s.type)?1:s.length}function x(s){return s==="softclip"||s==="hardclip"||s==="insertion"}function q(s,e,t,o){let r=s[t][o];r===void 0&&(r=s[t][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),r.entryDepth++,r[e]++}function S(s,e,t,o,r){let n=s[t][o];n===void 0&&(n=s[t][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),n.entryDepth++,n.probabilities.push(r),n[e]++}function G({feature:s,region:e,bins:t,skipmap:o}){var r;const n=s.get("start"),f=s.get("strand"),i=(r=s.get("mismatches"))!==null&&r!==void 0?r:[];for(const c of i){const l=n+c.start,p=L(c),u=l+p;for(let a=l;a<l+p;a++){const d=a-e.start;if(d>=0&&d<t.length){const m=t[d],{base:b,altbase:h,type:g}=c,D=x(g);g==="deletion"||g==="skip"?(q(m,f,"delskips",g),m.depth--):D?q(m,f,"noncov",g):(q(m,f,"snps",b),m.ref.entryDepth--,m.ref[f]--,m.refbase=h)}}if(c.type==="skip"){const a=s.get("tags"),d=(a==null?void 0:a.XS)||(a==null?void 0:a.TS),m=a==null?void 0:a.ts,b=d==="+"?1:d==="-"?-1:(m==="+"?1:d==="-"?-1:0)*f,h=`${l}_${u}_${b}`;o[h]===void 0&&(o[h]={feature:s,start:l,end:u,strand:f,effectiveStrand:b,score:0}),o[h].score++}}}function V({feature:s,colorBy:e,region:t,bins:o,regionSequence:r}){var n,f;const i=s.get("start"),c=s.get("strand"),l=s.get("end"),p=(n=e==null?void 0:e.modifications)===null||n===void 0?void 0:n.twoColor,u=(f=e==null?void 0:e.modifications)===null||f===void 0?void 0:f.isolatedModification,a=I(s);if(a){let d=0;for(const{type:m,prob:b,allProbs:h}of a){if(u&&m!==u)return;const g=d+i-t.start;if(g>=0&&g<o.length&&d+i<l){o[g]===void 0&&(o[g]={depth:0,readsCounted:0,snps:{},ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},mods:{},nonmods:{},delskips:{},noncov:{}});const D=1-_.sum(h),v=o[g];v.refbase=r[g],p&&D>_.max(h)?S(v,c,"nonmods",`nonmod_${m}`,D):S(v,c,"mods",`mod_${m}`,b)}d++}}}function W({feature:s,region:e,bins:t,regionSequence:o}){var r;const n=s.get("start"),f=s.get("end"),i=s.get("strand"),c=s.get("seq"),l=(r=s.get("mismatches"))!==null&&r!==void 0?r:[],p=o.toLowerCase();if(c){const u=P(s.get("CIGAR")),{methBins:a,methProbs:d}=F(s,u),m=l.filter(b=>b.type==="deletion");for(let b=0;b<f-n;b++){const h=b+n,g=p[h-e.start+1],D=p[h-e.start+2];if(g==="c"&&D==="g"){const v=t[h-e.start],y=t[h-e.start+1],M=a[b],j=a[b+1],A=d[b],C=d[b+1];M&&(A===void 0||A>.5)||j&&(C===void 0||C>.5)?(v&&(S(v,i,"mods","cpg_meth",A||0),v.ref.entryDepth--,v.ref[i]--),y&&(S(y,i,"mods","cpg_meth",C||0),y.ref.entryDepth--,y.ref[i]--)):(v&&(m.some(w=>_.doesIntersect2(h,h+1,w.start+n,w.start+n+w.length))||(S(v,i,"nonmods","cpg_unmeth",1-(A||0)),v.ref.entryDepth--,v.ref[i]--)),y&&(m.some(w=>_.doesIntersect2(h+1,h+2,w.start+n,w.start+n+w.length))||(S(y,i,"nonmods","cpg_unmeth",1-(C||0)),y.ref.entryDepth--,y.ref[i]--)))}}}}async function X({fetchSequence:s,features:e,region:t,opts:o}){const{stopToken:r,colorBy:n}=o,f={},i=[],c=Math.max(0,t.start-1),l=t.start-c;let p=performance.now();for(const u of e){if(performance.now()-p>400&&(O(r),p=performance.now()),B({feature:u,bins:i,region:t}),(n==null?void 0:n.type)==="modifications"){const a=await s({...t,start:c,end:t.end+1})||"";V({feature:u,colorBy:n,bins:i,region:t,regionSequence:a.slice(l)})}else if((n==null?void 0:n.type)==="methylation"){const a=await s({...t,start:c,end:t.end+1})||"";W({feature:u,bins:i,region:t,regionSequence:a})}G({feature:u,skipmap:f,bins:i,region:t})}for(const u of i)u&&(u.mods=Object.fromEntries(Object.entries(u.mods).map(([a,d])=>[a,{...d,avgProbability:d.probabilities.length?_.sum(d.probabilities)/d.probabilities.length:void 0}])),u.nonmods=Object.fromEntries(Object.entries(u.nonmods).map(([a,d])=>[a,{...d,avgProbability:d.probabilities.length?_.sum(d.probabilities)/d.probabilities.length:void 0}])));return{bins:i,skipmap:f}}class H extends R.BaseFeatureDataAdapter{async configure(){var e,t;const o=this.getConf("subadapter"),r=o.sequenceAdapter,n=await((e=this.getSubAdapter)===null||e===void 0?void 0:e.call(this,o)),f=r?await((t=this.getSubAdapter)===null||t===void 0?void 0:t.call(this,r)):void 0;if(!n)throw new Error("Failed to get subadapter");return{subadapter:n.dataAdapter,sequenceAdapter:f==null?void 0:f.dataAdapter}}async fetchSequence(e){const{sequenceAdapter:t}=await this.configure();if(t)return $(e,t)}getFeatures(e,t={}){return E(async o=>{const{subadapter:r}=await this.configure(),n=await N.firstValueFrom(r.getFeatures(e,t).pipe(T.toArray())),{bins:f,skipmap:i}=await X({features:n,region:e,opts:t,fetchSequence:l=>this.fetchSequence(l)});let c=0;for(const l of f){if(l){const p=e.start+c;o.next(new k({id:`${this.id}-${p}`,data:{score:l.depth,snpinfo:l,start:p,end:p+1,refName:e.refName}}))}c++}for(const[l,p]of Object.entries(i))o.next(new k({id:l,data:{type:"skip",start:p.start,end:p.end,strand:p.strand,score:p.score,effectiveStrand:p.effectiveStrand}}));o.complete()},t.stopToken)}async getMultiRegionFeatureDensityStats(e,t){const{subadapter:o}=await this.configure();return o.getMultiRegionFeatureDensityStats(e,t)}async getRefNames(e={}){const{subadapter:t}=await this.configure();return t.getRefNames(e)}freeResources(){}}export{H as default};
//# sourceMappingURL=SNPCoverageAdapter-COwRwdGf.js.map
