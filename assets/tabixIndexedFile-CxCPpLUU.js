import{ca as V,cm as B,d$ as D,ce as K,cf as Q,e0 as Z}from"./index-CT2bM4yV.js";class ee extends Error{}function N(s){if(s&&s.aborted){if(typeof DOMException<"u")throw new DOMException("aborted","AbortError");{const e=new ee("aborted");throw e.code="ERR_ABORTED",e}}}function te(s,e){return e.minv.blockPosition-s.maxv.blockPosition<65e3&&e.maxv.blockPosition-s.minv.blockPosition<5e6}function G(s,e){const t=[];let n=null;return s.length===0?s:(s.sort(function(i,a){const o=i.minv.blockPosition-a.minv.blockPosition;return o!==0?o:i.minv.dataPosition-a.minv.dataPosition}),s.forEach(i=>{(!e||i.maxv.compareTo(e)>0)&&(n===null?(t.push(i),n=i):te(n,i)?i.maxv.compareTo(n.maxv)>0&&(n.maxv=i.maxv):(t.push(i),n=i))}),t)}class z{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}}function S(s,e=0){return new z(s[e+7]*1099511627776+s[e+6]*4294967296+s[e+5]*16777216+s[e+4]*65536+s[e+3]*256+s[e+2],s[e+1]<<8|s[e])}class A{constructor(e,t,n,i=void 0){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class X{constructor({filehandle:e,renameRefSeqs:t=n=>n}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch(t=>{throw this.parseP=void 0,t})),this.parseP}async hasRefSeq(e,t={}){var i;return!!((i=(await this.parse(t)).indices[e])!=null&&i.binIndex)}}const W=65536,ne=W*W;function Y(s,e=0){const t=s[e]|s[e+1]<<8|s[e+2]<<16|s[e+3]<<24;return((s[e+4]|s[e+5]<<8|s[e+6]<<16|s[e+7]<<24)>>>0)*ne+(t>>>0)}const ie=21578324,H=14;function re(s,e){return s+=1,e-=1,[[0,0],[1+(s>>26),1+(e>>26)],[9+(s>>23),9+(e>>23)],[73+(s>>20),73+(e>>20)],[585+(s>>17),585+(e>>17)],[4681+(s>>14),4681+(e>>14)]]}class y extends X{async lineCount(e,t={}){var o;const n=await this.parse(t),i=n.refNameToId[e];return i===void 0||!n.indices[i]?-1:((o=n.indices[i].stats)==null?void 0:o.lineCount)??-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await V(t);N(e.signal);const i=new DataView(n.buffer);if(i.getUint32(0,!0)!==ie)throw new Error("Not a TBI file");const o=i.getUint32(4,!0),r=i.getUint32(8,!0),l=r&65536?"zero-based-half-open":"1-based-closed",c={0:"generic",1:"SAM",2:"VCF"}[r&15];if(!c)throw new Error(`invalid Tabix preset format flags ${r}`);const f={ref:i.getInt32(12,!0),start:i.getInt32(16,!0),end:i.getInt32(20,!0)},d=i.getInt32(24,!0),x=5,p=((1<<(x+1)*3)-1)/7,w=2**(14+x*3),b=d?String.fromCharCode(d):null,h=i.getInt32(28,!0),I=i.getInt32(32,!0),{refNameToId:g,refIdToName:v}=this._parseNameBytes(n.slice(36,36+I));let m=36+I,C;return{indices:new Array(o).fill(0).map(()=>{const F=i.getInt32(m,!0);m+=4;const P={};let $;for(let T=0;T<F;T+=1){const _=i.getUint32(m,!0);if(m+=4,_>p+1)throw new Error("tabix index contains too many bins, please use a CSI index");if(_===p+1){const k=i.getInt32(m,!0);m+=4,k===2&&($=this.parsePseudoBin(n,m)),m+=16*k}else{const k=i.getInt32(m,!0);m+=4;const U=new Array(k);for(let M=0;M<k;M+=1){const q=S(n,m),J=S(n,m+8);m+=16,C=this._findFirstData(C,q),U[M]=new A(q,J,_)}P[_]=U}}const O=i.getInt32(m,!0);m+=4;const L=new Array(O);for(let T=0;T<O;T+=1)L[T]=S(n,m),m+=8,C=this._findFirstData(C,L[T]);return{binIndex:P,linearIndex:L,stats:$}}),metaChar:b,maxBinNumber:p,maxRefLength:w,skipLines:h,firstDataLine:C,columnNumbers:f,coordinateType:l,format:c,refIdToName:v,refNameToId:g,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:Y(e,t+16)}}_parseNameBytes(e){let t=0,n=0;const i=[],a={},o=new TextDecoder("utf8");for(let r=0;r<e.length;r+=1)if(!e[r]){if(n<r){const l=this.renameRefSeq(o.decode(e.subarray(n,r)));i[t]=l,a[l]=t}n=r+1,t+=1}return{refNameToId:a,refIdToName:i}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const a=await this.parse(i),o=a.refNameToId[e];if(o===void 0)return[];const r=a.indices[o];if(!r)return[];(r.linearIndex.length?r.linearIndex[t>>H>=r.linearIndex.length?r.linearIndex.length-1:t>>H]:new z(0,0))||console.warn("querying outside of possible tabix range");const u=re(t,n),c=[];for(const[w,b]of u)for(let h=w;h<=b;h++)if(r.binIndex[h])for(const I of r.binIndex[h])c.push(new A(I.minv,I.maxv,h));const f=r.linearIndex.length;let d=null;const x=Math.min(t>>14,f-1),p=Math.min(n>>14,f-1);for(let w=x;w<=p;++w){const b=r.linearIndex[w];b&&(!d||b.compareTo(d)<0)&&(d=b)}return G(c,d)}}const se=21582659,ae=38359875,oe={0:"generic",1:"SAM",2:"VCF"};function ce(s,e){return s*2**e}function j(s,e){return Math.floor(s/2**e)}class R extends X{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t),i=n.refNameToId[e];if(i===void 0||!n.indices[i])return-1;const{stats:o}=n.indices[i];return o?o.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=new DataView(e.buffer),i=n.getInt32(t,!0),a=i&65536?"zero-based-half-open":"1-based-closed",o=oe[i&15];if(!o)throw new Error(`invalid Tabix preset format flags ${i}`);const r={ref:n.getInt32(t+4,!0),start:n.getInt32(t+8,!0),end:n.getInt32(t+12,!0)},l=n.getInt32(t+16,!0),u=l?String.fromCharCode(l):null,c=n.getInt32(t+20,!0),f=n.getInt32(t+24,!0),{refIdToName:d,refNameToId:x}=this._parseNameBytes(e.subarray(t+28,t+28+f));return{refIdToName:d,refNameToId:x,skipLines:c,metaChar:u,columnNumbers:r,format:o,coordinateType:a}}_parseNameBytes(e){let t=0,n=0;const i=[],a={},o=new TextDecoder("utf8");for(let r=0;r<e.length;r+=1)if(!e[r]){if(n<r){const l=this.renameRefSeq(o.decode(e.subarray(n,r)));i[t]=l,a[l]=t}n=r+1,t+=1}return{refNameToId:a,refIdToName:i}}async _parse(e={}){const t=await V(await this.filehandle.readFile(e)),n=new DataView(t.buffer);let i;if(n.getUint32(0,!0)===se)i=1;else if(n.getUint32(0,!0)===ae)i=2;else throw new Error("Not a CSI file");this.minShift=n.getInt32(4,!0),this.depth=n.getInt32(8,!0),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const a=2**(this.minShift+this.depth*3),o=n.getInt32(12,!0),r=o&&o>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:null,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},l=n.getInt32(16+o,!0);let u,c=16+o+4;const f=new Array(l).fill(0).map(()=>{const d=n.getInt32(c,!0);c+=4;const x={};let p;for(let w=0;w<d;w+=1){const b=n.getUint32(c,!0);if(b>this.maxBinNumber)p=this.parsePseudoBin(t,c+4),c+=48;else{const h=S(t,c+4);u=this._findFirstData(u,h);const I=n.getInt32(c+12,!0);c+=16;const g=new Array(I);for(let v=0;v<I;v+=1){const m=S(t,c),C=S(t,c+8);c+=16,g[v]=new A(m,C,b)}x[b]=g}}return{binIndex:x,stats:p}});return{...r,csi:!0,refCount:l,maxBlockSize:65536,firstDataLine:u,csiVersion:i,indices:f,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:a}}parsePseudoBin(e,t){return{lineCount:Y(e,t+28)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const a=await this.parse(i),o=a.refNameToId[e];if(o===void 0)return[];const r=a.indices[o];if(!r)return[];const l=this.reg2bins(t,n),u=[];for(const[c,f]of l)for(let d=c;d<=f;d++)if(r.binIndex[d])for(const x of r.binIndex[d])u.push(new A(x.minv,x.maxv,d));return G(u,new z(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,i=0,a=this.minShift+this.depth*3;const o=[];for(;n<=this.depth;a-=3,i+=ce(1,n*3),n+=1){const r=i+j(e,a),l=i+j(t,a);if(l-r+o.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);o.push([r,l])}return o}}function le(s){return/^[\u0000-\u007F]*$/.test(s)}class fe{constructor({path:e,filehandle:t,url:n,tbiPath:i,tbiUrl:a,tbiFilehandle:o,csiPath:r,csiUrl:l,csiFilehandle:u,renameRefSeqs:c=d=>d,chunkCacheSize:f=5*2**20}){if(t)this.filehandle=t;else if(e)this.filehandle=new B(e);else if(n)this.filehandle=new D(n);else throw new TypeError("must provide either filehandle or path");if(o)this.index=new y({filehandle:o,renameRefSeqs:c});else if(u)this.index=new R({filehandle:u,renameRefSeqs:c});else if(i)this.index=new y({filehandle:new B(i),renameRefSeqs:c});else if(r)this.index=new R({filehandle:new B(r),renameRefSeqs:c});else if(e)this.index=new y({filehandle:new B(`${e}.tbi`),renameRefSeqs:c});else if(l)this.index=new R({filehandle:new D(l)});else if(a)this.index=new y({filehandle:new D(a)});else if(n)this.index=new y({filehandle:new D(`${n}.tbi`)});else throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl");this.renameRefSeq=c,this.chunkCache=new K({cache:new Q({maxSize:Math.floor(f/65536)}),fill:(d,x)=>this.readChunk(d,{signal:x})})}async getLines(e,t,n,i){let a,o={},r;typeof i=="function"?r=i:(o=i,r=i.lineCallback,a=i.signal);const l=await this.index.getMetadata(o);N(a);const u=t??0,c=n??l.maxRefLength;if(!(u<=c))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(u===c)return;const f=await this.index.blocksForRange(e,u,c,o);N(a);const d=new TextDecoder("utf8");for(const x of f){const{buffer:p,cpositions:w,dpositions:b}=await this.chunkCache.get(x.toString(),x,a);N(a);let h=0,I=0;const g=d.decode(p),v=le(g);for(;h<g.length;){let m,C;if(v){if(C=g.indexOf(`
`,h),C===-1)break;m=g.slice(h,C)}else{if(C=p.indexOf(10,h),C===-1)break;const P=p.slice(h,C);m=d.decode(P)}if(b){for(;h+x.minv.dataPosition>=b[I++];);I--}const{startCoordinate:E,overlaps:F}=this.checkLine(l,e,u,c,m);if(F)r(m,w[I]*256+(h-b[I])+x.minv.dataPosition+1);else if(E!==void 0&&E>=c)return;h=C+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:i}=await this.getMetadata(e);N(e.signal);const a=((t==null?void 0:t.blockPosition)||0)+i,o=await this.filehandle.read(a,0,e),r=await V(o);if(n){let l=-1;const u=10,c=n.charCodeAt(0);for(let f=0;f<r.length&&!(f===l+1&&r[f]!==c);f+=1)r[f]===u&&(l=f);return r.subarray(0,l+1)}return r}async getHeader(e={}){const t=new TextDecoder("utf8"),n=await this.getHeaderBuffer(e);return t.decode(n)}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,i,a){const{columnNumbers:o,metaChar:r,coordinateType:l,format:u}=e;if(r&&a.startsWith(r))return{overlaps:!1};let{ref:c,start:f,end:d}=o;c||(c=0),f||(f=0),d||(d=0),u==="VCF"&&(d=8);const x=Math.max(c,f,d);let p=1,w=0,b="",h=-1/0;const I=a.length;for(let g=0;g<I+1;g++)if(a[g]==="	"||g===I){if(p===c){if(this.renameRefSeq(a.slice(w,g))!==t)return{overlaps:!1}}else if(p===f){if(h=parseInt(a.slice(w,g),10),l==="1-based-closed"&&(h-=1),h>=i)return{startCoordinate:h,overlaps:!1};if((d===0||d===f)&&h+1<=n)return{startCoordinate:h,overlaps:!1}}else if(u==="VCF"&&p===4)b=a.slice(w,g);else if(p===d&&(u==="VCF"?this._getVcfEnd(h,b,a.slice(w,g)):Number.parseInt(a.slice(w,g),10))<=n)return{overlaps:!1};if(w=g+1,p+=1,p>x)break}return{startCoordinate:h,overlaps:!0}}_getVcfEnd(e,t,n){let i=e+t.length;const a=n.includes("SVTYPE=TRA");if(n[0]!=="."&&!a){let o=";";for(let r=0;r<n.length;r+=1){if(o===";"&&n.slice(r,r+4)==="END="){let l=n.indexOf(";",r);l===-1&&(l=n.length),i=parseInt(n.slice(r+4,l),10);break}o=n[r]}}else if(a)return e+1;return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async readChunk(e,t={}){const n=await this.filehandle.read(e.fetchedSize(),e.minv.blockPosition,t);return Z(n,e)}}export{fe as T};
//# sourceMappingURL=tabixIndexedFile-CxCPpLUU.js.map
