import{B as A,i as h,r as C,a as g,O as P}from"./util-eIttPhVK.js";import{a3 as x}from"./index-CT2bM4yV.js";class F extends A.BaseFeatureDataAdapter{async setup(e){return this.setupP||(this.setupP=this.setupPre(e).catch(s=>{throw this.setupP=void 0,s})),this.setupP}async setupPre(e){const s=this.getConf("assemblyNames"),a=this.pluginManager,o=h.openLocation(this.getConf("bed1Location"),a),c=h.openLocation(this.getConf("bed2Location"),a),n=h.openLocation(this.getConf("mcscanAnchorsLocation"),a),[r,u,i]=await Promise.all([o,c,n].map(t=>C(t,e))),m=g(r),p=g(u),f=i.split(/\n|\r\n|\r/).filter(t=>!!t&&t!=="###").map((t,d)=>{const[N,y,w]=t.split("	"),l=m.get(N),b=p.get(y);if(!l||!b)throw new Error(`feature not found, ${N} ${y} ${l} ${b}`);return[l,b,+w,d]});return{assemblyNames:s,feats:f}}async hasDataForRefName(){return!0}getAssemblyNames(){return this.getConf("assemblyNames")}async getRefNames(e={}){var s;const a=(s=e.regions)===null||s===void 0?void 0:s[0].assemblyName,{feats:o}=await this.setup(e),c=this.getAssemblyNames().indexOf(a);if(c!==-1){const n=new Set;for(const r of o)n.add(c===0?r[0].refName:r[1].refName);return[...n]}return console.warn("Unable to do ref renaming on adapter"),[]}getFeatures(e,s={}){return P(async a=>{const{assemblyNames:o,feats:c}=await this.setup(s),n=o.indexOf(e.assemblyName);if(n!==-1){const r=n===0;for(const u of c){const[i,m,p,f]=u,[t,d]=r?[i,m]:[m,i];t.refName===e.refName&&x.doesIntersect2(e.start,e.end,t.start,t.end)&&a.next(new x.SimpleFeature({...t,uniqueId:`${n}-${f}`,syntenyId:f,strand:t.strand*d.strand,assemblyName:o[+!r],score:p,mate:{...d,assemblyName:o[+r]}}))}}a.complete()})}freeResources(){}}F.capabilities=["getFeatures","getRefNames"];export{F as default};
//# sourceMappingURL=MCScanAnchorsAdapter-zbGAjvp5.js.map
