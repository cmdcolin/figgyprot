import{ef as A,bG as y,eg as I,bF as g,eh as O}from"./index-CGKDrrCR.js";class L{constructor(e=[],i){this.data={};const{checkIndent:c=!0,skipValidation:l=!1}=i??{},s=typeof e=="string"?e.trimEnd().split(/\r?\n/):e;let o,t;for(const d of s){if(d==="")throw new Error("Invalid stanza, contained blank lines");if(d.trim().startsWith("#"))continue;if(d.trimEnd().endsWith("\\")){const f=d.trimEnd().slice(0,-1);t?t+=f.trimStart():t=f;continue}let m=d;if(t&&(m=t+m.trimStart(),t=void 0),o??c){const f=/^([ \t]+)/.exec(m);if(o===void 0)f?[,o]=f:o="";else if(o===""&&f!==null||o&&f&&o!==f[1])throw new Error("Inconsistent indentation of stanza")}else o="";const n=m.trim(),h=n.indexOf(" ");if(h===-1){if(!this.nameKey)throw new Error("First line in a stanza must have both a key and a value");if(this.data[n])continue;this.data[n]="";continue}const r=n.slice(0,h),u=n.slice(h+1);if(this.data[r]&&u!==this.data[r])throw new Error(`Got duplicate key with a different value in stanza: "${r}" key has both ${this.data[r]} and ${u}`);this.nameKey||(this.nameKey=r,this.name=n.slice(h+1)),this.data[r]=u}l||this.validate()}validate(){}}class C{constructor(e=[],i){this.data={};const{checkIndent:c=!0,skipValidation:l=!1}=i??{},s=typeof e=="string"?e.trimEnd().split(/(?:[\t ]*\r?\n){2,}/):e;for(const o of s){if(o==="")throw new Error("Invalid stanza, was empty");if(o.startsWith("include")||o.trim().startsWith("#")&&o.trimEnd().split(/\r?\n/).map(m=>m.trim()).every(m=>m.startsWith("#")))continue;const t=new L(o,{checkIndent:c});if(!this.nameKey)this.nameKey=t.nameKey;else if(t.nameKey!==this.nameKey)throw new Error(`The first line in each stanza must have the same key. Saw both ${this.nameKey} and ${t.nameKey}`);if(!t.name)throw new Error(`No stanza name: ${t.name}`);if(this.data[t.name])throw new Error(`Got duplicate stanza name: ${t.name}`);this.data[t.name]=t}l||this.validate()}validate(){}}function v(a,e,i=""){const c=[];for(const l of e)a.data[l]||c.push(l);if(c.length>0)throw new Error(`${i} is missing required entr${c.length===1?"y":"ies"}: ${c.join(", ")}`)}class P extends C{constructor(e,i){super(e,{...i,checkIndent:!1})}validate(){var e;if(this.nameKey!=="track")throw new Error(`trackDb has "${this.nameKey}" instead of "track" as the first line in each track`);for(const[i,c]of Object.entries(this.data)){const l=Object.keys(c.data);v(c,["track","shortLabel"],`Track ${i}`);const s=new Set(["superTrack","compositeTrack","container","view"]);if(!l.some(d=>s.has(d))){if(!l.includes("bigDataUrl"))throw new Error(`Track ${i} is missing required key "bigDataUrl"`);if(!l.includes("type")&&!Object.keys(this.settings(i)).includes("type"))throw new Error(`Neither track ${i} nor any of its parent tracks have the required key "type"`)}let o=i;do o=(e=this.data[o])===null||e===void 0?void 0:e.parent,o&&([o]=o.split(" "));while(o);const t=this.data[i];t&&(this.data[i]=t)}}settings(e){var i;if(!this.data[e])throw new Error(`Track ${e} does not exist`);const c=[e];let l=e;do l=(i=this.data[l])===null||i===void 0?void 0:i.parent,l&&c.push(l);while(l);const s={};c.reverse();for(const o of c){const t=this.data[o];if(t)for(const[d,m]of Object.entries(t))s[d]=m}return s}}class q extends C{validate(e=["genome","trackDb"]){if(this.nameKey!=="genome")throw new Error('Genomes file must begin with a line like "genome <genome_name>"');for(const[i,c]of Object.entries(this.data))v(c,e,`genome ${i}`)}}class W extends L{validate(){v(this,["hub","shortLabel","longLabel","genomesFile","email"],"Hub file")}}class H{constructor(e){const[i,c,...l]=e.trimEnd().split(/(?:[\t ]*\r?\n){2,}/);this.hubData=new L(i),this.validateHub(),this.genome=new L(c),this.validateGenomeSection(),this.tracks=new P(l.join(`

`),{skipValidation:!1})}validateHub(){if(this.hubData.nameKey!=="hub")throw new Error('Hub file must begin with a line like "hub <hub_name>"');v(this.hubData,["hub","shortLabel","longLabel","email","descriptionUrl"])}validateGenomeSection(){if(this.genome.nameKey!=="genome")throw new Error('Genomes file must begin with a line like "genome <genome_name>"')}}async function R(a){const e=await A.openLocation(a).readFile("utf8");return new q(e)}async function _(a){const e=await A.openLocation(a).readFile("utf8");return new P(e)}function x(a,e){return{uri:new URL(a,new URL(e.uri,e.baseUri)).href,locationType:"UriLocation"}}function U(a,e,i){return x(a||e,i)}function k(a,e){return a?{uri:a,locationType:"LocalPath"}:{uri:e,locationType:"UriLocation"}}function b(a,e){return new URL(a,e).href}function N({trackDb:a,trackDbLoc:e,assemblyName:i,sequenceAdapter:c,baseUrl:l}){const s=new Set(["superTrack","compositeTrack","container","view"]);return Object.entries(a.data).map(([o,t])=>{var d;const{data:m}=t;if(!Object.keys(m).some(n=>s.has(n))){const n=[];let h=o;do h=((d=a.data[h])===null||d===void 0?void 0:d.data.parent)||"",h&&(h=h.split(" ")[0],n.push(a.data[h]));while(h);return n.reverse(),{metadata:{...t.data,...t.data.html?{html:`<a href="${b(t.data.html,l)}">${t.data.html}</a>`}:{}},category:[t.data.group,...n.map(r=>r==null?void 0:r.data.group).filter(r=>!!r)].filter(r=>!!r),...V({track:t,trackDbLoc:e,trackDb:a,sequenceAdapter:c})}}}).filter(y.notEmpty).map(o=>({...o,trackId:`ucsc-trackhub-${y.objectHash(o)}`,assemblyNames:[i]}))}function V({track:a,trackDbLoc:e,trackDb:i,sequenceAdapter:c}){var l;const{data:s}=a,o=s.parent||"",t=s.bigDataUrl||"",d=s.bigDataIndex||"",m=s.type||((l=i.data[o])===null||l===void 0?void 0:l.data.type)||"",n=(s.shortLabel||"")+(t.includes("xeno")?" (xeno)":""),h=y.isUriLocation(e);let r=m.split(" ")[0]||"";r==="bam"&&t.toLowerCase().endsWith("cram")&&(r="cram");const u=h?x(t,e):k(t);return r==="bam"?{type:"AlignmentsTrack",name:n,description:s.longLabel,adapter:{type:"BamAdapter",bamLocation:u,index:{location:h?U(d,`${t}.bai`,e):k(d,`${t}.bai`)}}}:r==="cram"?{type:"AlignmentsTrack",name:n,description:s.longLabel,adapter:{type:"CramAdapter",cramLocation:u,craiLocation:h?U(d,`${t}.crai`,e):k(d,`${t}.crai`),sequenceAdapter:c}}:r==="bigWig"?{type:"QuantitativeTrack",name:n,description:s.longLabel,adapter:{type:"BigWigAdapter",bigWigLocation:u}}:r.startsWith("big")?{type:"FeatureTrack",name:n,description:s.longLabel,adapter:{type:"BigBedAdapter",bigBedLocation:u}}:r==="vcfTabix"?{type:"VariantTrack",name:n,description:s.longLabel,adapter:{type:"VcfTabixAdapter",vcfGzLocation:u,index:{location:h?U(d,`${t}.tbi`,e):k(d,`${t}.tbi`)}}}:r==="hic"?{type:"HicTrack",name:n,description:s.longLabel,adapter:{type:"HicAdapter",hicLocation:u}}:I.generateUnknownTrackConf(n,r)}async function Q(a){var e;const{pluginManager:i}=y.getEnv(a),c=y.getSession(a),l=[];try{const s=g.getConf(a,"hubTxtLocation"),o=await A.openLocation(s).readFile("utf8"),t=b(s.uri,s.baseUri),{assemblyManager:d}=c;if(o.includes("useOneFile on")){const m=new H(o),{genome:n,tracks:h}=m,r=n.name,u=n.data.description;d.get(r)||c.addSessionAssembly({name:r,displayName:u,sequence:{type:"ReferenceSequenceTrack",metadata:{...n.data,...n.data.htmlPath?{htmlPath:`<a href="${b(n.data.htmlPath,t)}">${n.data.htmlPath}</a>`}:{}},trackId:`${r}-${O.nanoid()}`,adapter:{type:"TwoBitAdapter",twoBitLocation:{uri:b(n.data.twoBitPath,t)},chromSizesLocation:{uri:b(n.data.chromSizes,t)}}},...n.data.chromAliasBb?{refNameAliases:{adapter:{type:"BigBedAdapter",uri:b(n.data.chromAliasBb,t)}}}:{}});const w=d.get(r),T=g.getConf(w,["sequence","adapter"]),$=N({trackDb:h,trackDbLoc:s,assemblyName:r,sequenceAdapter:T,baseUrl:t});a.addTrackConfs($),i.evaluateExtensionPoint("LaunchView-LinearGenomeView",{session:c,assembly:r,tracklist:!0,loc:n.data.defaultPos})}else{const n=new W(o).data.genomesFile;if(!n)throw new Error("genomesFile not found on hub");const h=b(s.uri,s.baseUri),r=h?{uri:b(n,h),locationType:"UriLocation"}:{localPath:n,locationType:"LocalPathLocation"},u=await R(r),f={};for(const[p,E]of Object.entries(u.data)){const K=g.getConf(a,"assemblyNames");if(K.length>0&&!K.includes(p))continue;const S=d.get(p);if(!S){l.push(p);continue}const F=E.data.trackDb;if(!F)throw new Error("genomesFile not found on hub");const B=new URL(n,h),z=h?{uri:new URL(F,B).href,locationType:"UriLocation"}:{localPath:F,locationType:"LocalPathLocation"},D=await _(z),G=g.getConf(S,["sequence","adapter"]),j=N({trackDb:D,trackDbLoc:z,assemblyName:p,sequenceAdapter:G,baseUrl:h});a.addTrackConfs(j),f[p]=j.length}const w=Object.entries(f),T=w.length?`Loaded data from these assemblies: ${w.map(([p,E])=>`${p} (${E} tracks)`).join(", ")}`:"",$=l.length?`Skipped data from these assemblies: ${l.join(", ")}`:"";c.notify([T,$].filter(p=>!!p).join(". "),"success")}}catch(s){console.error(s),c.notifyError(`${g.getConf(a,"name")}: "${s}"`,s),(e=c.breakConnection)===null||e===void 0||e.call(c,a.configuration)}}export{Q as doConnect};
//# sourceMappingURL=doConnect-DA_JrfEs.js.map
