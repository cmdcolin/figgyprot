import{u as P,ah as E,y as F,aB as L,a6 as B}from"./index-BXtJZUZx.js";import{B as I}from"./index-7uUUtqbY.js";import{r as O}from"./rxjs-B_16j8uU.js";import{S as j}from"./index-Cef45cG-.js";import{z as R,p as $,f as k,s as v,b as z}from"./util-DTuZfkC4.js";function D(c){const t={};for(const e of c){const a=e.qname,i=e.tname,m=`${a}-${i}`;t[m]||(t[m]={quals:[],len:[]}),t[m].quals.push(e.extra.mappingQual||1),t[m].len.push(e.extra.blockLen||1)}const s=Object.fromEntries(Object.entries(t).map(([e,a])=>{const i=R(a.quals,a.len);return[e,Q(i)]}));for(const e of c){const a=e.qname,i=e.tname,m=`${a}-${i}`;e.extra.meanScore=s[m]}let n=1e4,o=0;for(const e of c)n=Math.min(e.extra.meanScore||0,n),o=Math.max(e.extra.meanScore||0,o);for(const e of c){const a=e.extra.meanScore||0;e.extra.meanScore=(a-n)/(o-n)}return c}function Q(c){const[t,s]=c.reduce(([n,o],[e,a])=>[n+e*a,o+a],[0,0]);return t/s}const{parseCigar:U}=B;class G extends I.BaseFeatureDataAdapter{async setup(t){return this.setupP||(this.setupP=this.setupPre(t).catch(s=>{throw this.setupP=void 0,s})),this.setupP}async setupPre(t){return $(await P.fetchAndMaybeUnzip(E.openLocation(this.getConf("pafLocation"),this.pluginManager),t),z,t)}async hasDataForRefName(){return!0}getAssemblyNames(){const t=this.getConf("assemblyNames");if(t.length===0){const s=this.getConf("queryAssembly"),n=this.getConf("targetAssembly");return[s,n]}return t}async getRefNames(t={}){var s;const n=(s=t.regions)===null||s===void 0?void 0:s[0].assemblyName,o=await this.setup(t),e=this.getAssemblyNames().indexOf(n);if(e!==-1){const a=new Set;for(const i of o)a.add(e===0?i.qname:i.tname);return[...a]}return console.warn("Unable to do ref renaming on adapter"),[]}getFeatures(t,s={}){return O.ObservableCreate(async n=>{let o=await this.setup(s);const{config:e}=s;e&&F.readConfObject(e,"colorBy")==="meanQueryIdentity"&&(o=D(o));const a=this.getAssemblyNames(),{start:i,end:m,refName:C,assemblyName:u}=t,N=a.indexOf(u),p=N===0;N===-1&&(console.warn(`${u} not found in this adapter`),n.complete());for(let f=0;f<o.length;f++){const r=o[f];let d=0,y=0,g="",h="",x=0,b=0;p?(d=r.qstart,y=r.qend,g=r.qname,h=r.tname,x=r.tstart,b=r.tend):(d=r.tstart,y=r.tend,g=r.tname,h=r.qname,x=r.qstart,b=r.qend);const{extra:l,strand:A}=r;if(g===C&&L.doesIntersect2(i,m,d,y)){const{numMatches:S=0,blockLen:w=1,cg:W,...M}=l;let q=l.cg;l.cg&&(p&&A===-1?q=k(U(l.cg)).join(""):p&&(q=v(l.cg))),n.next(new j({uniqueId:f+u,assemblyName:u,start:d,end:y,type:"match",refName:g,strand:A,...M,CIGAR:q,syntenyId:f,identity:S/w,numMatches:S,blockLen:w,mate:{start:x,end:b,refName:h,assemblyName:a[+p]}}))}}n.complete()})}}G.capabilities=["getFeatures","getRefNames"];export{G as default};
//# sourceMappingURL=PAFAdapter-VD2HqkIy.js.map
