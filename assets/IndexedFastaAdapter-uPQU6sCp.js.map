{"version":3,"file":"IndexedFastaAdapter-uPQU6sCp.js","sources":["../../node_modules/@gmod/indexedfasta/esm/indexedFasta.js","../../node_modules/@jbrowse/plugin-sequence/esm/IndexedFastaAdapter/IndexedFastaAdapter.js"],"sourcesContent":["import { LocalFile } from 'generic-filehandle2';\nfunction _faiOffset(idx, pos) {\n    return (idx.offset +\n        idx.lineBytes * Math.floor(pos / idx.lineLength) +\n        (pos % idx.lineLength));\n}\nasync function readFAI(fai, opts = {}) {\n    const decoder = new TextDecoder('utf8');\n    return Object.fromEntries(decoder\n        .decode((await fai.readFile(opts)))\n        .split(/\\r?\\n/)\n        .map(r => r.trim())\n        .filter(f => !!f)\n        .map(line => line.split('\\t'))\n        .map(row => {\n        if (row[0]?.startsWith('>')) {\n            throw new Error('found > in sequence name, might have supplied FASTA file for the FASTA index');\n        }\n        return [\n            row[0],\n            {\n                name: row[0],\n                length: +row[1],\n                start: 0,\n                end: +row[1],\n                offset: +row[2],\n                lineLength: +row[3],\n                lineBytes: +row[4],\n            },\n        ];\n    }));\n}\nexport default class IndexedFasta {\n    constructor({ fasta, fai, path, faiPath, }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass filehandle for fasta or path to localfile');\n        }\n        if (fai) {\n            this.fai = fai;\n        }\n        else if (faiPath) {\n            this.fai = new LocalFile(faiPath);\n        }\n        else if (path) {\n            this.fai = new LocalFile(`${path}.fai`);\n        }\n        else {\n            throw new Error('Need to pass filehandle for  or path to localfile');\n        }\n    }\n    async _getIndexes(opts) {\n        if (!this.indexes) {\n            this.indexes = readFAI(this.fai, opts).catch((e) => {\n                this.indexes = undefined;\n                throw e;\n            });\n        }\n        return this.indexes;\n    }\n    /**\n     * @returns array of string sequence names that are present in the index, in\n     * which the array index indicates the sequence ID, and the value is the\n     * sequence name\n     */\n    async getSequenceNames(opts) {\n        return Object.keys(await this._getIndexes(opts));\n    }\n    /**\n     * @returns array of string sequence names that are present in the index, in\n     * which the array index indicates the sequence ID, and the value is the\n     * sequence name\n     */\n    async getSequenceSizes(opts) {\n        const returnObject = {};\n        const idx = await this._getIndexes(opts);\n        for (const val of Object.values(idx)) {\n            returnObject[val.name] = val.length;\n        }\n        return returnObject;\n    }\n    /**\n     * @returns array of string sequence names that are present in the index, in\n     * which the array index indicates the sequence ID, and the value is the\n     * sequence name\n     */\n    async getSequenceSize(seqName, opts) {\n        const idx = await this._getIndexes(opts);\n        return idx[seqName]?.length;\n    }\n    /**\n     * @param name\n     *\n     * @returns true if the file contains the given reference sequence name\n     */\n    async hasReferenceSequence(name, opts) {\n        return !!(await this._getIndexes(opts))[name];\n    }\n    /**\n     * @param seqName\n     * @param min\n     * @param max\n     */\n    async getResiduesByName(seqName, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts))[seqName];\n        return indexEntry\n            ? this._fetchFromIndexEntry(indexEntry, min, max, opts)\n            : undefined;\n    }\n    //alias for getResiduesByName\n    async getSequence(seqName, min, max, opts) {\n        return this.getResiduesByName(seqName, min, max, opts);\n    }\n    async _fetchFromIndexEntry(indexEntry, min = 0, max, opts) {\n        let end = max;\n        if (min < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        if (end === undefined || end > indexEntry.length) {\n            end = indexEntry.length;\n        }\n        if (min >= end) {\n            return '';\n        }\n        const position = _faiOffset(indexEntry, min);\n        const readlen = _faiOffset(indexEntry, end) - position;\n        const decoder = new TextDecoder('utf8');\n        return decoder\n            .decode(await this.fasta.read(readlen, position, opts))\n            .replace(/\\s+/g, '');\n    }\n}\n//# sourceMappingURL=indexedFasta.js.map","import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport { IndexedFasta } from '@gmod/indexedfasta';\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, updateStatus2 } from '@jbrowse/core/util';\nimport QuickLRU from '@jbrowse/core/util/QuickLRU';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nexport default class IndexedFastaAdapter extends BaseSequenceAdapter {\n    constructor() {\n        super(...arguments);\n        this.seqCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 200 }),\n            fill: async (args) => {\n                const { refName, start, end, fasta } = args;\n                return fasta.getSequence(refName, start, end);\n            },\n        });\n    }\n    async getRefNames(_opts) {\n        const { fasta } = await this.setup();\n        return fasta.getSequenceNames();\n    }\n    async getRegions(_opts) {\n        const { fasta } = await this.setup();\n        const seqSizes = await fasta.getSequenceSizes();\n        return Object.keys(seqSizes).map(refName => ({\n            refName,\n            start: 0,\n            end: seqSizes[refName],\n        }));\n    }\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        return {\n            fasta: new IndexedFasta({\n                fasta: openLocation(fastaLocation, this.pluginManager),\n                fai: openLocation(faiLocation, this.pluginManager),\n            }),\n        };\n    }\n    async getHeader() {\n        const loc = this.getConf('metadataLocation');\n        return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n            ? null\n            : openLocation(loc, this.pluginManager).readFile('utf8');\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    getFeatures(region, opts) {\n        const { statusCallback = () => { }, stopToken } = opts || {};\n        const { refName, start, end } = region;\n        return ObservableCreate(async (observer) => {\n            await updateStatus2('Downloading sequence', statusCallback, stopToken, async () => {\n                const { fasta } = await this.setup();\n                const size = await fasta.getSequenceSize(refName);\n                const regionEnd = Math.min(size || 0, end);\n                const chunks = [];\n                const chunkSize = 128000;\n                const s = start - (start % chunkSize);\n                const e = end + (chunkSize - (end % chunkSize));\n                for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n                    const r = {\n                        refName,\n                        start: chunkStart,\n                        end: chunkStart + chunkSize,\n                    };\n                    checkStopToken(stopToken);\n                    const res = await this.seqCache.get(JSON.stringify(r), {\n                        ...r,\n                        fasta,\n                    });\n                    if (!res) {\n                        break;\n                    }\n                    chunks.push(res);\n                }\n                const seq = chunks\n                    .filter(f => !!f)\n                    .join('')\n                    .slice(start - s)\n                    .slice(0, end - start);\n                if (seq) {\n                    observer.next(new SimpleFeature({\n                        id: `${refName}-${start}-${regionEnd}`,\n                        data: {\n                            refName,\n                            start,\n                            end: regionEnd,\n                            seq,\n                        },\n                    }));\n                }\n            });\n            observer.complete();\n        });\n    }\n}\n"],"names":["_faiOffset","idx","pos","readFAI","fai","opts","decoder","r","f","line","row","_a","IndexedFasta","fasta","path","faiPath","LocalFile","e","returnObject","val","seqName","name","min","max","indexEntry","end","position","readlen","IndexedFastaAdapter","BaseSequenceAdapter","AbortablePromiseCache","QuickLRU","args","refName","start","_opts","seqSizes","fastaLocation","faiLocation","openLocation","loc","region","statusCallback","stopToken","ObservableCreate","observer","updateStatus2","size","regionEnd","chunks","chunkSize","s","chunkStart","checkStopToken","res","seq","SimpleFeature"],"mappings":"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","x_google_ignoreList":[0,1]}