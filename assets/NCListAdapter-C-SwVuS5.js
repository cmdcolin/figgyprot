import{bs as D,bN as z,ce as _,cf as U,dZ as M,d$ as q,e9 as O,ea as I}from"./index-CGKDrrCR.js";var L={exports:{}};(function(y,t){(function(e,s){y.exports=s()})(z,function(){const e=/^[\w+.-]+:\/\//,s=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,i=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function r(a){return e.test(a)}function n(a){return a.startsWith("//")}function h(a){return a.startsWith("/")}function l(a){return a.startsWith("file:")}function d(a){return/^[.?#]/.test(a)}function g(a){const c=s.exec(a);return u(c[1],c[2]||"",c[3],c[4]||"",c[5]||"/",c[6]||"",c[7]||"")}function p(a){const c=i.exec(a),o=c[2];return u("file:","",c[1]||"","",h(o)?o:"/"+o,c[3]||"",c[4]||"")}function u(a,c,o,m,w,f,k){return{scheme:a,user:c,host:o,port:m,path:w,query:f,hash:k,type:7}}function b(a){if(n(a)){const o=g("http:"+a);return o.scheme="",o.type=6,o}if(h(a)){const o=g("http://foo.com"+a);return o.scheme="",o.host="",o.type=5,o}if(l(a))return p(a);if(r(a))return g(a);const c=g("http://foo.com/"+a);return c.scheme="",c.host="",c.type=a?a.startsWith("?")?3:a.startsWith("#")?2:4:1,c}function C(a){if(a.endsWith("/.."))return a;const c=a.lastIndexOf("/");return a.slice(0,c+1)}function T(a,c){E(c,c.type),a.path==="/"?a.path=c.path:a.path=C(c.path)+a.path}function E(a,c){const o=c<=4,m=a.path.split("/");let w=1,f=0,k=!1;for(let F=1;F<m.length;F++){const R=m[F];if(!R){k=!0;continue}if(k=!1,R!=="."){if(R===".."){f?(k=!0,f--,w--):o&&(m[w++]=R);continue}m[w++]=R,f++}}let S="";for(let F=1;F<w;F++)S+="/"+m[F];(!S||k&&!S.endsWith("/.."))&&(S+="/"),a.path=S}function A(a,c){if(!a&&!c)return"";const o=b(a);let m=o.type;if(c&&m!==7){const f=b(c),k=f.type;switch(m){case 1:o.hash=f.hash;case 2:o.query=f.query;case 3:case 4:T(o,f);case 5:o.user=f.user,o.host=f.host,o.port=f.port;case 6:o.scheme=f.scheme}k>m&&(m=k)}E(o,m);const w=o.query+o.hash;switch(m){case 2:case 3:return w;case 4:{const f=o.path.slice(1);return f?d(c||a)&&!d(f)?"./"+f+w:f+w:w||"."}case 5:return o.path+w;default:return o.scheme+"//"+o.user+o.host+o.port+o.path+w}}return A})})(L);var J=L.exports;const P=D(J);async function v(y,t,e={}){const{defaultContent:s={}}=e;try{const i=await t(y,{encoding:"utf8"}),r=new TextDecoder("utf8");return JSON.parse(r.decode(i))}catch(i){if(i.code==="ENOENT"||i.status===404||i.message.includes("404")||i.message.includes("ENOENT"))return s;throw i}}function N(y,t="."){return P(y,t)}class W{constructor({readFile:t,cacheSize:e=100}){if(this.topList=[],this.chunkCache=new _({cache:new U({maxSize:e}),fill:this.readChunkItems.bind(this)}),this.readFile=t,!this.readFile)throw new Error('must provide a "readFile" function')}importExisting(t,e,s,i,r){this.topList=t,this.attrs=e,this.start=e.makeFastGetter("Start"),this.end=e.makeFastGetter("End"),this.lazyClass=r,this.baseURL=s,this.lazyUrlTemplate=i}binarySearch(t,e,s){let i=-1,r=t.length,n;for(;r-i>1;)n=i+r>>>1,s(t[n])>=e?r=n:i=n;return s===this.end?r:i}readChunkItems(t){const e=N(this.lazyUrlTemplate.replaceAll(/\{Chunk\}/gi,t),this.baseURL);return v(e,this.readFile,{defaultContent:[]})}async*iterateSublist(t,e,s,i,r,n,h){const l=this.attrs.makeGetter("Chunk"),d=this.attrs.makeGetter("Sublist"),g=[];for(let p=this.binarySearch(t,e,r);p<t.length&&p>=0&&i*n(t[p])<i*s;p+=i){if(t[p][0]===this.lazyClass){const b=l(t[p]),C=this.chunkCache.get(b,b).then(T=>[T,b]);g.push(C)}else yield[t[p],h.concat(p)];const u=d(t[p]);u&&(yield*this.iterateSublist(u,e,s,i,r,n,h.concat(p)))}for(const p of g){const[u,b]=await p;u&&(yield*this.iterateSublist(u,e,s,i,r,n,[...h,b]))}}async*iterate(t,e){const s=t>e?-1:1,i=t>e?this.start:this.end,r=t>e?this.end:this.start;this.topList.length>0&&(yield*this.iterateSublist(this.topList,t,e,s,i,r,[0]))}async histogram(t,e,s){const i=new Array(s);i.fill(0);const r=(e-t)/s;for await(const n of this.iterate(t,e)){const h=Math.max(0,(this.start(n)-t)/r|0),l=Math.min(s,(this.end(n)-t)/r|0);for(let d=h;d<=l;d+=1)i[d]+=1}return i}}class ${constructor(t){this.classes=t,this.fields=[];for(let e=0;e<t.length;e+=1){this.fields[e]={};for(let s=0;s<t[e].attributes.length;s+=1)this.fields[e][t[e].attributes[s]]=s+1;t[e].proto===void 0&&(t[e].proto={}),t[e].isArrayAttr===void 0&&(t[e].isArrayAttr={})}}attrIndices(t){return this.classes.map(e=>e.attributes.indexOf(t)+1||e.attributes.indexOf(t.toLowerCase())+1||void 0)}get(t,e){if(e in this.fields[t[0]])return t[this.fields[t[0]][e]];const s=e.toLowerCase();if(s in this.fields[t[0]])return t[this.fields[t[0]][s]];const i=this.classes[t[0]].attributes.length+1;return i>=t.length||!(e in t[i])?e in this.classes[t[0]].proto?this.classes[t[0]].proto[e]:void 0:t[i][e]}makeSetter(t){return(e,s)=>{this.set(e,t,s)}}makeGetter(t){return e=>this.get(e,t)}makeFastGetter(t){const e=this.attrIndices(t);return function(i){if(e[i[0]]!==void 0)return i[e[i[0]]]}}accessors(){return this._accessors||(this._accessors=this._makeAccessors()),this._accessors}_makeAccessors(){const t={},e={get(i){const r=this.get.field_accessors[i.toLowerCase()];if(r)return r.call(this)},set(i,r){const n=this.set.field_accessors[i];if(n)return n.call(this,r)},tags(){return s[this[0]]||[]}};e.get.field_accessors={},e.set.field_accessors={},this.classes.forEach((i,r)=>{(i.attributes||[]).forEach((n,h)=>{t[n]=t[n]||[],t[n][r]=h+1,n=n.toLowerCase(),t[n]=t[n]||[],t[n][r]=h+1})});const s=this.classes.map(i=>i.attributes);return Object.keys(t).forEach(i=>{const r=t[i];e.get.field_accessors[i]=r?function(){return this[r[this[0]]]}:function(){}}),e}}class G{constructor({urlTemplate:t,chunkSize:e,length:s,cacheSize:i=100,readFile:r},n){if(this.urlTemplate=t,this.chunkSize=e,this.length=s,this.baseUrl=n===void 0?"":n,this.readFile=r,!r)throw new Error("must provide readFile callback");this.chunkCache=new _({cache:new U({maxSize:i}),fill:this.getChunk.bind(this)})}index(t,e,s){this.range(t,t,e,void 0,s)}async*range(t,e){t=Math.max(0,t),e=Math.min(e,this.length-1);const s=Math.floor(t/this.chunkSize),i=Math.floor(e/this.chunkSize),r=[];for(let n=s;n<=i;n+=1)r.push(this.chunkCache.get(n,n));for(const n of r){const[h,l]=await n;yield*this.filterChunkData(t,e,h,l)}}async getChunk(t){let e=this.urlTemplate.replaceAll(/\{Chunk\}/gi,t);this.baseUrl&&(e=N(e,this.baseUrl));const s=await v(e,this.readFile);return[t,s]}*filterChunkData(t,e,s,i){const r=s*this.chunkSize,n=Math.max(0,t-r),h=Math.min(e-r,this.chunkSize-1);for(let l=n;l<=h;l+=1)yield[l+r,i[l]]}}function H(){return this._uniqueID}function Z(){return this._parent}function j(){return this.get("subfeatures")}class K{constructor({baseUrl:t,urlTemplate:e,readFile:s,cacheSize:i=10}){if(this.baseUrl=t,this.urlTemplates={root:e},this.readFile=s,!this.readFile)throw new Error('must provide a "readFile" function argument');this.dataRootCache=new _({cache:new U({maxSize:i}),fill:this.fetchDataRoot.bind(this)})}makeNCList(){return new W({readFile:this.readFile})}loadNCList(t,e,s){t.nclist.importExisting(e.intervals.nclist,t.attrs,s,e.intervals.urlTemplate,e.intervals.lazyClass)}getDataRoot(t){return this.dataRootCache.get(t,t)}fetchDataRoot(t){const e=N(this.urlTemplates.root.replaceAll(/{\s*refseq\s*}/g,t),this.baseUrl);return v(e,this.readFile).then(s=>this.parseTrackInfo(s,e))}parseTrackInfo(t,e){const s={nclist:this.makeNCList(),stats:{featureCount:t.featureCount||0}};t.intervals&&(s.attrs=new $(t.intervals.classes),this.loadNCList(s,t,e));const{histograms:i}=t;if(i!=null&&i.meta){for(let r=0;r<i.meta.length;r+=1)i.meta[r].lazyArray=new G({...i.meta[r].arrayParams,readFile:this.readFile},e);s._histograms=i}return s._histograms&&Object.keys(s._histograms).forEach(r=>{s._histograms[r].forEach(h=>{Object.keys(h).forEach(l=>{typeof h[l]=="string"&&String(Number(h[l]))===h[l]&&(h[l]=Number(h[l]))})})}),s}async getRegionStats(t){return(await this.getDataRoot(t.ref)).stats}async getRegionFeatureDensities({refName:t,start:e,end:s,numBins:i,basesPerBin:r}){const n=await this.getDataRoot(t);if(i)r=(s-e)/i;else if(r)i=Math.ceil((s-e)/r);else throw new TypeError("numBins or basesPerBin arg required for getRegionFeatureDensities");const l=(n._histograms.stats||[]).find(u=>u.basesPerBin>=r);let d=n._histograms.meta[0];for(let u=0;u<n._histograms.meta.length;u+=1)r>=n._histograms.meta[u].basesPerBin&&(d=n._histograms.meta[u]);let g=r/d.basesPerBin;if(g>.9&&Math.abs(g-Math.round(g))<1e-4){const u=Math.floor(e/d.basesPerBin);g=Math.round(g);const b=[];for(let C=0;C<i;C+=1)b[C]=0;for await(const[C,T]of d.lazyArray.range(u,u+g*i-1))b[Math.floor((C-u)/g)]+=T;return{bins:b,stats:l}}return{bins:await n.nclist.histogram(e,s,i),stats:l}}async*getFeatures({refName:t,start:e,end:s}){var n;const i=await this.getDataRoot(t),r=(n=i.attrs)==null?void 0:n.accessors();for await(const[h,l]of i.nclist.iterate(e,s)){if(!h.decorated){const d=l.join(",");this.decorateFeature(r,h,`${t},${d}`)}yield h}}decorateFeature(t,e,s,i){e.get=t.get,e.tags=t.tags,e._uniqueID=s,e.id=H,e._parent=i,e.parent=Z,e.children=j,(e.get("subfeatures")||[]).forEach((r,n)=>{this.decorateFeature(t,r,`${s}-${n}`,e)}),e.decorated=!0}}const Q={refName:"seq_id"},V={seq_id:"refName"};class x{constructor(t,e,s){this.ncFeature=t,this.uniqueId=s||t.id(),this.parentHandle=e}set(){throw new Error("not implemented")}jb2TagToJb1Tag(t){return(Q[t]||t).toLowerCase()}jb1TagToJb2Tag(t){const e=t.toLowerCase();return V[e]||e}get(t){const e=this.ncFeature.get(this.jb2TagToJb1Tag(t));return e&&t==="subfeatures"?e.map(s=>new x(s,this)):e}tags(){return this.ncFeature.tags().map(t=>this.jb1TagToJb2Tag(t))}id(){return this.uniqueId}parent(){return this.parentHandle}children(){return this.get("subfeatures")}toJSON(){const t={uniqueId:this.id()};for(const e of this.ncFeature.tags()){const s=this.jb1TagToJb2Tag(e),i=this.ncFeature.get(e);s==="subfeatures"?t.subfeatures=(i||[]).map(r=>new x(r,this).toJSON()):t[s]=i}return t}}class Y extends M.BaseFeatureDataAdapter{constructor(t,e,s){super(t,e,s);const i=this.getConf("refNames"),r=this.getConf("rootUrlTemplate");this.configRefNames=i,this.nclist=new K({baseUrl:"",urlTemplate:r.uri,readFile:n=>new q(String(r.baseUri?new URL(n,r.baseUri).toString():n)).readFile()})}getFeatures(t,e={}){return O(async s=>{const{stopToken:i}=e;for await(const r of this.nclist.getFeatures(t,e))I(i),s.next(this.wrapFeature(r));s.complete()})}wrapFeature(t){return new x(t,void 0,`${this.id}-${t.id()}`)}async hasDataForRefName(t){var e;const s=await this.nclist.getDataRoot(t);return!!(!((e=s==null?void 0:s.stats)===null||e===void 0)&&e.featureCount)}async getRefNames(){return this.configRefNames||[]}freeResources(){}}export{Y as default};
//# sourceMappingURL=NCListAdapter-C-SwVuS5.js.map
