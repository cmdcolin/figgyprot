{"version":3,"file":"BgzipFastaAdapter-C821hbTD.js","sources":["../../node_modules/@gmod/bgzf-filehandle/esm/long.js","../../node_modules/@gmod/bgzf-filehandle/esm/gziIndex.js","../../node_modules/@gmod/bgzf-filehandle/esm/bgzFilehandle.js","../../node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","../../node_modules/@jbrowse/plugin-sequence/esm/BgzipFastaAdapter/BgzipFastaAdapter.js"],"sourcesContent":["export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","import { LocalFile } from 'generic-filehandle2';\nimport { longFromBytesToUnsigned } from \"./long.js\";\nconst UNCOMPRESSED_POSITION = 1;\n// binary search to find the block that the\n// read starts in and extend forward from that\nfunction compare(position, entry, nextEntry) {\n    const uncompressedPosition = entry[UNCOMPRESSED_POSITION];\n    const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity;\n    if (uncompressedPosition <= position && nextUncompressedPosition > position) {\n        // block overlaps read start\n        return 0;\n    }\n    else if (uncompressedPosition < position) {\n        // block is before read start\n        return -1;\n    }\n    else {\n        // block is after read start\n        return 1;\n    }\n}\nexport default class GziIndex {\n    constructor({ filehandle, path, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else {\n            throw new TypeError('either filehandle or path must be defined');\n        }\n    }\n    _getIndex() {\n        if (!this.index) {\n            this.index = this._readIndex().catch((e) => {\n                this.index = undefined;\n                throw e;\n            });\n        }\n        return this.index;\n    }\n    async _readIndex() {\n        const buf = await this.filehandle.read(8, 0);\n        const numEntries = longFromBytesToUnsigned(buf);\n        if (!numEntries) {\n            return [[0, 0]];\n        }\n        const entries = new Array(numEntries + 1);\n        entries[0] = [0, 0];\n        // TODO rewrite this to make an index-index that stays in memory\n        const bufSize = 8 * 2 * numEntries;\n        if (bufSize > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError('integer overflow');\n        }\n        const b2 = await this.filehandle.read(bufSize, 8);\n        for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n            const compressedPos = longFromBytesToUnsigned(b2, entryNumber * 16);\n            const uncompressedPos = longFromBytesToUnsigned(b2, entryNumber * 16 + 8);\n            entries[entryNumber + 1] = [compressedPos, uncompressedPos];\n        }\n        return entries;\n    }\n    async getLastBlock() {\n        const entries = await this._getIndex();\n        return entries.at(-1);\n    }\n    async getRelevantBlocksForRead(length, position) {\n        const endPosition = position + length;\n        if (length === 0) {\n            return [];\n        }\n        const entries = await this._getIndex();\n        const relevant = [];\n        let lowerBound = 0;\n        let upperBound = entries.length - 1;\n        let searchPosition = Math.floor(entries.length / 2);\n        let comparison = compare(position, entries[searchPosition], entries[searchPosition + 1]);\n        while (comparison !== 0) {\n            if (comparison > 0) {\n                upperBound = searchPosition - 1;\n            }\n            else if (comparison < 0) {\n                lowerBound = searchPosition + 1;\n            }\n            searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound;\n            comparison = compare(position, entries[searchPosition], entries[searchPosition + 1]);\n        }\n        // here's where we read forward\n        relevant.push(entries[searchPosition]);\n        let i = searchPosition + 1;\n        for (; i < entries.length; i += 1) {\n            relevant.push(entries[i]);\n            if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n                break;\n            }\n        }\n        if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n            relevant.push([]);\n        }\n        return relevant;\n    }\n}\n//# sourceMappingURL=gziIndex.js.map","import { LocalFile } from 'generic-filehandle2';\nimport { unzip } from \"./unzip.js\";\nimport GziIndex from \"./gziIndex.js\";\nimport { concatUint8Array } from \"./util.js\";\nexport default class BgzFilehandle {\n    constructor({ filehandle, path, gziFilehandle, gziPath, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else {\n            throw new TypeError('either filehandle or path must be defined');\n        }\n        if (!gziFilehandle && !gziPath && !path) {\n            throw new TypeError('either gziFilehandle or gziPath must be defined');\n        }\n        this.gzi = new GziIndex({\n            filehandle: gziFilehandle,\n            path: !gziFilehandle && !gziPath && path ? gziPath : `${path}.gzi`,\n        });\n    }\n    async _readAndUncompressBlock(compressedPosition, nextCompressedPosition) {\n        let next = nextCompressedPosition;\n        if (!next) {\n            next = (await this.filehandle.stat()).size;\n        }\n        // read the compressed data into the block buffer\n        const blockCompressedLength = next - compressedPosition;\n        const blockBuffer = await this.filehandle.read(blockCompressedLength, compressedPosition);\n        // uncompress it\n        return unzip(blockBuffer);\n    }\n    async read(length, position) {\n        const blockPositions = await this.gzi.getRelevantBlocksForRead(length, position);\n        const blocks = [];\n        for (let blockNum = 0; blockNum < blockPositions.length - 1; blockNum += 1) {\n            const uncompressedBuffer = await this._readAndUncompressBlock(blockPositions[blockNum][0], blockPositions[blockNum + 1][0]);\n            const [, uncompressedPosition] = blockPositions[blockNum];\n            const sourceOffset = uncompressedPosition >= position ? 0 : position - uncompressedPosition;\n            const sourceEnd = Math.min(position + length, uncompressedPosition + uncompressedBuffer.length) - uncompressedPosition;\n            if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n                blocks.push(uncompressedBuffer.subarray(sourceOffset, sourceEnd));\n            }\n        }\n        return concatUint8Array(blocks);\n    }\n}\n//# sourceMappingURL=bgzFilehandle.js.map","import { BgzfFilehandle } from '@gmod/bgzf-filehandle';\nimport IndexedFasta from \"./indexedFasta.js\";\nexport default class BgzipIndexedFasta extends IndexedFasta {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, }) {\n        super({ fasta, path, fai, faiPath });\n        if (fasta && gzi) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                path,\n                gziPath,\n            });\n        }\n    }\n}\n//# sourceMappingURL=bgzipIndexedFasta.js.map","import { BgzipIndexedFasta } from '@gmod/indexedfasta';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter';\nexport default class BgzipFastaAdapter extends IndexedFasta {\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        const gziLocation = this.getConf('gziLocation');\n        const fastaOpts = {\n            fasta: openLocation(fastaLocation, this.pluginManager),\n            fai: openLocation(faiLocation, this.pluginManager),\n            gzi: openLocation(gziLocation, this.pluginManager),\n        };\n        return { fasta: new BgzipIndexedFasta(fastaOpts) };\n    }\n}\n"],"names":["TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","UNCOMPRESSED_POSITION","compare","position","entry","nextEntry","uncompressedPosition","nextUncompressedPosition","GziIndex","filehandle","path","LocalFile","buf","numEntries","entries","bufSize","b2","entryNumber","compressedPos","uncompressedPos","length","endPosition","relevant","lowerBound","upperBound","searchPosition","comparison","BgzFilehandle","gziFilehandle","gziPath","compressedPosition","nextCompressedPosition","next","blockCompressedLength","blockBuffer","unzip","blockPositions","blocks","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","concatUint8Array","BgzipIndexedFasta","IndexedFasta","fasta","fai","faiPath","gzi","BgzfFilehandle","BgzipFastaAdapter","fastaLocation","faiLocation","gziLocation","fastaOpts","openLocation"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}